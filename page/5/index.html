<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta http-equiv="Cache-Control" content="max-age=86400" />
<meta name="baidu-site-verification" content="I3b2hxwJQe" />

<!-- <meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" /> -->






  <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="詹方的个人博客" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="詹方的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Fang -.-">
<meta property="og:url" content="http://www.demozhan.com/page/5/index.html">
<meta property="og:site_name" content="Fang -.-">
<meta property="og:description" content="詹方的个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fang -.-">
<meta name="twitter:description" content="詹方的个人博客">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post'
  };
</script>

  <title> Fang -.- </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f060a37ef3c67e7d80e0730ccf4c5f23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Fang -.-</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            <i class="menu-item-icon icon-next-commonweal"></i> <br />
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','http://7xltvd.com1.z0.glb.clouddn.com/swifty_st.js','_st');

  _st('install', '8paz1yFszaADHgDv8F_P','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/25/js闭包/" itemprop="url">
                js闭包
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-25T11:05:49+08:00" content="2015-09-25">
            2015-09-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/js/" itemprop="url" rel="index">
                  <span itemprop="name">js</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/25/js闭包/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/25/js闭包/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><code>我真是一只勤奋的编程狗，在火车上闲着没事还把闭包看了，之前对闭包只是简单地了解，这次算是弄懂了</code><br><code>惯例，这个还是参考了几篇博客 http://www.jb51.net/article/24101.htm 以及阮一峰的博客</code></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>官方”的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br>相信很少有人能直接看懂这句话，因为他描述的太学术。其实这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。看下面这段代码：</p>
<pre><code>function a() { 
 var i = 0; 
 function b() { alert(++i); } 
 return b;
}
var c = a();
c();
</code></pre><p>这段代码有两个特点：</p>
<ul>
<li>函数b嵌套在函数a内部；</li>
<li>函数a返回函数b。</li>
</ul>
<p>引用关系如下图：<br><img src="http://7xltvd.com1.z0.glb.clouddn.com/闭包.jpg" alt="Alt" title="闭包引用关系图"></p>
<p>这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：<br> <strong><em>当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。</em></strong></p>
<p>所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新的值，和上次那次调用的是各自独立的。</p>
<h2 id="闭包有什么作用"><a href="#闭包有什么作用" class="headerlink" title="闭包有什么作用"></a>闭包有什么作用</h2><p>闭包的作用就是在a执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源，因为a的内部函数b的执行需要依赖a中的变量。<br>在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后alert出i的值。<br>那么我们来想象另一种情况，如果a返回的不是函数b，情况就完全不同了。因为a执行完后，b没有被返回给a的外界，只是被a所引用，而此时a也只会被b引 用，因此函数a和b互相引用但又不被外界打扰(被外界引用)，函数a和b就会被GC回收。(关于Javascript的垃圾回收机制将在后面详细介绍)</p>
<h2 id="闭包内的微观世界"><a href="#闭包内的微观世界" class="headerlink" title="闭包内的微观世界"></a>闭包内的微观世界</h2><p>如果要更加深入的了解闭包以及函数a和嵌套函数b的关系，我们需要引入另外几个概念：函数的执行环境(excution context)、活动对象(call object)、作用域(scope)、作用域链(scope chain)。以函数a从定义到执行的过程为例阐述这几个概念。</p>
<ul>
<li>当定义函数a的时候，js解释器会将函数a的作用域链(scope chain)设置为定义a时a所在的“环境”，如果a是一个全局函数，则scope chain中只有window对象。</li>
<li>当执行函数a的时候，a会进入相应的执行环境(excution context)。<br>在创建执行环境的过程中，首先会为a添加一个scope属性，即a的作用域，其值就为第1步中的scope chain。即a.scope=a的作用域链。</li>
<li>然后执行环境会创建一个活动对象(call object)。活动对象也是一个拥有属性的对象，但它不具有原型而且不能通过JavaScript代码直接访问。创建完活动对象后，把活动对象添加到a的作用域链的最顶端。此时a的作用域链包含了两个对象：a的活动对象和window对象。</li>
<li>下一步是在活动对象上添加一个arguments属性，它保存着调用函数a时所传递的参数。<br>最后把所有函数a的形参和内部的函数b的引用也添加到a的活动对象上。在这一步中，完成了函数b的的定义，因此如同第3步，函数b的作用域链被设置为b所被定义的环境，即a的作用域。</li>
<li>到此，整个函数a从定义到执行的步骤就完成了。此时a返回函数b的引用给c，又函数b的作用域链包含了对函数a的活动对象的引用，也就是说b可以访问到a中定义的所有变量和函数。函数b被c引用，函数b又依赖函数a，因此函数a在返回后不会被GC回收。<br>当函数b执行的时候亦会像以上步骤一样。因此，执行时b的作用域链包含了3个对象：b的活动对象、a的活动对象和window对象，如下图所示：</li>
</ul>
<p><img src="http://7xltvd.com1.z0.glb.clouddn.com/作用域.jpg" alt="Alt" title="javascript作用域链"><br>如图所示，当在函数b中访问一个变量的时候，搜索顺序是：</p>
<ul>
<li>先搜索自身的活动对象，如果存在则返回，如果不存在将继续搜索函数a的活动对象，依次查找，直到找到为止。</li>
<li>如果函数b存在prototype原型对象，则在查找完自身的活动对象后先查找自身的原型对象，再继续查找。这就是Javascript中的变量查找机制。</li>
<li><p>如果整个作用域链上都无法找到，则返回undefined。</p>
<p>小结，本段中提到了两个重要的词语：函数的定义与执行。文中提到函数的作用域是在定义函数时候就已经确定，而不是在执行的时候确定（参看步骤1和3）。用一段代码来说明这个问题：</p>
<p>  function f(x) { </p>
<pre><code>var g = function () { return x; }
return g;
</code></pre><p>  }<br>  var h = f(1);<br>  alert(h());<br>这段代码中变量h指向了f中的那个匿名函数(由g返回)。<br>假设函数h的作用域是在执行alert(h())确定的，那么此时h的作用域链是：h的活动对象-&gt;alert的活动对象-&gt;window对象。<br>假设函数h的作用域是在定义时确定的，就是说h指向的那个匿名函数在定义的时候就已经确定了作用域。那么在执行的时候，h的作用域链为：h的活动对象-&gt;f的活动对象-&gt;window对象。<br>如果第一种假设成立，那输出值就是undefined；如果第二种假设成立，输出值则为1。<br>运行结果证明了第2个假设是正确的，说明函数的作用域确实是在定义这个函数的时候就已经确定了。</p>
</li>
</ul>
<h2 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h2><ul>
<li>保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。</li>
<li>在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。</li>
<li><p>通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）<br>私有属性和方法在Constructor外是无法被访问的</p>
<p>  function Constructor(…) {  </p>
<pre><code>var that = this;  
var membername = value; 
function membername(...) {...}
</code></pre><p>  }</p>
</li>
</ul>
<p>以上3点是闭包最基本的应用场景，很多经典案例都源于此。</p>
<h2 id="Javascript的垃圾回收机制"><a href="#Javascript的垃圾回收机制" class="headerlink" title="Javascript的垃圾回收机制"></a>Javascript的垃圾回收机制</h2><p>在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。</p>
<h2 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h2><ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，<strong>在退出函数之前，将不使用的局部变量全部删除。</strong></li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/23/网页性能管理/" itemprop="url">
                网页性能管理（转载自阮一峰）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-23T09:41:11+08:00" content="2015-09-23">
            2015-09-23
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/js/" itemprop="url" rel="index">
                  <span itemprop="name">js</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/23/网页性能管理/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/23/网页性能管理/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><code>贴出链接 http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html</code></p>
<p><strong>核心其实是读写分离</strong></p>
<h2 id="网页生成的过程"><a href="#网页生成的过程" class="headerlink" title="网页生成的过程"></a>网页生成的过程</h2><p><img src="http://7xltvd.com1.z0.glb.clouddn.com/网页生成过程.png" alt="Alt text" title="网页生成过程"></p>
<p>网页的生成过程，大致可以分成五步。</p>
<ul>
<li>HTML代码转化成DOM</li>
<li>CSS代码转化成CSSOM（CSS Object Model）</li>
<li>结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）</li>
<li>生成布局（layout），即将所有渲染树的所有节点进行平面合成</li>
<li>将布局绘制（paint）在屏幕上</li>
</ul>
<p>这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。</p>
<p>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。</p>
<p><img src="http://7xltvd.com1.z0.glb.clouddn.com/网页重排.png" alt="Alt text" title="网页生成过程"></p>
<h2 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h2><p>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。<br>以下三种情况，会导致网页重新渲染。</p>
<ul>
<li>修改DOM</li>
<li>修改样式表</li>
<li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li>
</ul>
<p>重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。</p>
<p>需要注意的是，<strong>“重绘”不一定需要”重排”</strong>，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，<strong>“重排”必然导致”重绘”</strong>，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。</p>
<h2 id="对于性能的影响"><a href="#对于性能的影响" class="headerlink" title="对于性能的影响"></a>对于性能的影响</h2><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。</p>
<p><strong>提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</strong></p>
<p>前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。</p>
<pre><code>div.style.color = &apos;blue&apos;;
div.style.marginTop = &apos;30px&apos;;
</code></pre><p>上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。<br>如果写得不好，就会触发两次重排和重绘。</p>
<pre><code>div.style.color = &apos;blue&apos;;
var margin = parseInt(div.style.marginTop);
div.style.marginTop = (margin + 10) + &apos;px&apos;;
</code></pre><p>上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。<br>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。</p>
<pre><code>offsetTop/offsetLeft/offsetWidth/offsetHeight
scrollTop/scrollLeft/scrollWidth/scrollHeight
clientTop/clientLeft/clientWidth/clientHeight
getComputedStyle()
</code></pre><p><strong>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。</strong></p>
<pre><code>// bad
div.style.left = div.offsetLeft + 10 + &quot;px&quot;;
div.style.top = div.offsetTop + 10 + &quot;px&quot;;

// good
var left = div.offsetLeft;
var top  = div.offsetTop;
div.style.left = left + 10 + &quot;px&quot;;
div.style.top = top + 10 + &quot;px&quot;;
</code></pre><p>一般的规则是：</p>
<ul>
<li>样式表越简单，重排和重绘就越快。</li>
<li>重排和重绘的DOM元素层级越高，成本就越高。</li>
<li>table元素的重排和重绘成本，要高于div元素</li>
</ul>
<h2 id="提高性能的九个技巧"><a href="#提高性能的九个技巧" class="headerlink" title="提高性能的九个技巧"></a>提高性能的九个技巧</h2><p>有一些技巧，可以降低浏览器重新渲染的频率和成本。</p>
<h3 id="第一条是上一节说到的，DOM-的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。"><a href="#第一条是上一节说到的，DOM-的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。" class="headerlink" title="第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。"></a>第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</h3><h3 id="第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。"><a href="#第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。" class="headerlink" title="第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。"></a>第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</h3><h3 id="第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。"><a href="#第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。" class="headerlink" title="第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。"></a>第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。</h3><pre><code>// bad
var left = 10;
var top = 10;
el.style.left = left + &quot;px&quot;;
el.style.top  = top  + &quot;px&quot;;

// good 
el.className += &quot; theclassname&quot;;

// good
el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;
</code></pre><h3 id="第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document-Fragment对象，完成后再把这个对象加入DOM。再比如，使用-cloneNode-方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。"><a href="#第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document-Fragment对象，完成后再把这个对象加入DOM。再比如，使用-cloneNode-方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。" class="headerlink" title="第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。"></a>第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</h3><h3 id="第五条，先将元素设为-display-none-（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。"><a href="#第五条，先将元素设为-display-none-（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。" class="headerlink" title="第五条，先将元素设为 display: none （需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。"></a>第五条，先将元素设为 display: none （需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</h3><h3 id="第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。"><a href="#第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。" class="headerlink" title="第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。"></a>第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</h3><h3 id="第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility-hidden-的元素只对重排有影响，不影响重绘。"><a href="#第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility-hidden-的元素只对重排有影响，不影响重绘。" class="headerlink" title="第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重排有影响，不影响重绘。"></a>第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden 的元素只对重排有影响，不影响重绘。</h3><h3 id="第八条，使用虚拟DOM的脚本库，比如React等。"><a href="#第八条，使用虚拟DOM的脚本库，比如React等。" class="headerlink" title="第八条，使用虚拟DOM的脚本库，比如React等。"></a>第八条，使用虚拟DOM的脚本库，比如React等。</h3><h3 id="第九条，使用-window-requestAnimationFrame-、window-requestIdleCallback-这两个方法调节重新渲染"><a href="#第九条，使用-window-requestAnimationFrame-、window-requestIdleCallback-这两个方法调节重新渲染" class="headerlink" title="第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染"></a>第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染</h3><h2 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h2><p>很多时候，密集的重新渲染是无法避免的，比如scroll事件的回调函数和网页动画。<br>网页动画的每一帧（frame）都是一次重新渲染。每秒低于24帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。如果能达到每秒70帧甚至80帧，就会极其流畅。</p>
<p>大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。</p>
<p><img src="http://7xltvd.com1.z0.glb.clouddn.com/刷新率.png" alt="Alt text" title="刷新率"></p>
<p>所以，如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。</p>
<p>一秒之间能够完成多少次重新渲染，这个指标就被称为”刷新率”，英文为FPS（frame per second）。60次重新渲染，就是60FPS。</p>
<h2 id="开发者工具的Timeline面板"><a href="#开发者工具的Timeline面板" class="headerlink" title="开发者工具的Timeline面板"></a>开发者工具的Timeline面板</h2><p>图太多了，懒得贴</p>
<h2 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame()"></a>window.requestAnimationFrame()</h2><p>有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。<br>其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。</p>
<pre><code>function doubleHeight(element) {
  var currentHeight = element.clientHeight;
  element.style.height = (currentHeight * 2) + &apos;px&apos;;
}
elements.forEach(doubleHeight);
</code></pre><p>上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。<br> 我们可以使用window.requestAnimationFrame()，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。</p>
<pre><code>function doubleHeight(element) {
  var currentHeight = element.clientHeight;
  window.requestAnimationFrame(function () {
    element.style.height = (currentHeight * 2) + &apos;px&apos;;
  });
}
elements.forEach(doubleHeight);
</code></pre><p>页面滚动事件（scroll）的监听函数，就很适合用 window.requestAnimationFrame() ，推迟到下一次重新渲染。</p>
<pre><code>$(window).on(&apos;scroll&apos;, function() {
   window.requestAnimationFrame(scrollHandler);
});
</code></pre><p>当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转1度。</p>
<pre><code>var rAF = window.requestAnimationFrame;

var degrees = 0;
function update() {
  div.style.transform = &quot;rotate(&quot; + degrees + &quot;deg)&quot;;
  console.log(&apos;updated to degrees &apos; + degrees);
  degrees = degrees + 1;
  rAF(update);
}
rAF(update);
</code></pre><h2 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h2><p>还有一个函数window.requestIdleCallback()，也可以用来调节重新渲染。<br>它指定只有当一帧的末尾有空闲时间，才会执行回调函数。</p>
<pre><code>requestIdleCallback(fn);
</code></pre><p>上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。<br>它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。</p>
<pre><code>requestIdleCallback(fn, 5000);
</code></pre><p>上面的代码表示，函数fn最迟会在5000毫秒之后执行。<br>函数 fn 可以接受一个 deadline 对象作为参数。</p>
<pre><code>requestIdleCallback(function someHeavyComputation(deadline) {
  while(deadline.timeRemaining() &gt; 0) {
    doWorkIfNeeded();
  }

  if(thereIsMoreWorkToDo) {
    requestIdleCallback(someHeavyComputation);
  }
});
</code></pre><p>上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。<br>deadline对象有一个方法和一个属性：timeRemaining() 和 didTimeout。<br>-（1）timeRemaining() 方法<br>timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮requestIdleCallback。<br>前面的示例代码之中，只要当前帧还有空闲时间，就不断调用doWorkIfNeeded方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮requestIdleCallback。<br>-（2）didTimeout属性<br>deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。<br>timeRemaining方法返回0<br>didTimeout 属性等于 true<br>因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。</p>
<pre><code>function myNonEssentialWork (deadline) {
  while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0)
    doWorkIfNeeded();

  if (tasks.length &gt; 0)
    requestIdleCallback(myNonEssentialWork);
}

requestIdleCallback(myNonEssentialWork, 5000);
</code></pre><p>上面代码确保了，doWorkIfNeeded 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。<br>Tip: requestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有Chrome支持</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/22/hexo加速/" itemprop="url">
                Hexo 静态博客加速
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-22T14:53:52+08:00" content="2015-09-22">
            2015-09-22
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端工具/" itemprop="url" rel="index">
                  <span itemprop="name">前端工具</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/22/hexo加速/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/22/hexo加速/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>参考 <a href="http://lukang.me/2014/hexo-page-speed.html" target="_blank" rel="external">http://lukang.me/2014/hexo-page-speed.html</a></p>
<p>目前我安装了 InstantClick，对于hexo访问速度没有变，可是打开文章的速度大幅增快<br>对于七牛加速，我目前只用来存储图片</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/22/ajax/" itemprop="url">
                ajax及跨域的几种办法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-22T10:54:13+08:00" content="2015-09-22">
            2015-09-22
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/22/ajax/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/22/ajax/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><code>之前一直用的是jquery的ajax、getJSON、和post，还是没有深入理解ajax</code></p>
<h2 id="ajax实例"><a href="#ajax实例" class="headerlink" title="ajax实例"></a>ajax实例</h2><p>具体的说明，请参考《javasicript 高级程序设计第三版》P572页</p>
<pre><code>function createXHR(){
    /*判断是否支持XMLHttpRequest*/
    if(typeof XMLHttpRequest != &quot;undefined&quot;){
        return new XMLHttpRequest();
    }else if(typeof ActiveXObject != &quot;undefined&quot;){
        if(typeof arguments.callee.activeXString != &quot;string&quot;) {
            var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],
                i, len;
            for (i = 0, len = versions.length; i &lt; len; i++) {
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                    break;
                } catch (ex) {
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    }else{
        throw new Error(&quot;No XHR object available&quot;);
    }
}

function newXHR(){
    var xhr = new createXHR();
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4){
            if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){
                alert(xhr.responseText);
            } else{
                alert(&quot;Request was unsuccessful: &quot; + xhr.status);
            }
        }
    }
    /*第三个选项表示是同步还是异步，ps:现在是同源访问index.php*/
    xhr.open(&quot;get&quot;,&quot;index.php&quot;,true);
    xhr.send(null);
}
</code></pre><h2 id="跨资源共享"><a href="#跨资源共享" class="headerlink" title="跨资源共享"></a>跨资源共享</h2><p><strong><em>同源即：相同的域，相同的端口，相同的协议，其他的都属于跨域</em></strong><br>基本大的方法CORS<br> 核心思想，使用自定义的http头部让浏览器与服务器进行沟通</p>
<h3 id="IE对CROS实现"><a href="#IE对CROS实现" class="headerlink" title="IE对CROS实现"></a>IE对CROS实现</h3><p>引入XDR（XDomainRequest）实现吧安全可靠的跨域通信<br>XDR与XHR的不同：</p>
<ul>
<li>cookie不会随请求发送</li>
<li>只能设置请求头中的Content-Type字段</li>
<li>不能访问响应头部的信息</li>
<li><p>只支持GET和POST请求</p>
<p>  var xdr = new XDomainRequest();<br>  xdr.onload = function(){</p>
<pre><code>alert(xdr.reponseText);
</code></pre><p>  };<br>  /<em>失败因素很多，需要捕获错误</em>/<br>  xdr.onerror = function(){</p>
<pre><code>alert(&quot;An error occurred&quot;);
</code></pre><p>  }<br>  xdr.open(“get”,”<a href="http://www.somewhere-else.com/page/" target="_blank" rel="external">http://www.somewhere-else.com/page/</a>“)<br>  xdr.send(null);</p>
</li>
</ul>
<p>对于发送post请求需要加入</p>
<pre><code>xdr.open(&quot;post&quot;,&quot;http://www.somewhere-else.com/page/&quot;);
xdr.contentType = &quot;appplication/x-www-form-urlencoded&quot;
xdr.send(&quot;name1=value&amp;name2=value2&quot;)
</code></pre><h3 id="其他浏览器对CROS"><a href="#其他浏览器对CROS" class="headerlink" title="其他浏览器对CROS"></a>其他浏览器对CROS</h3><p>直接在xhr中写入绝对url</p>
<pre><code>xdr.open(&quot;get&quot;,&quot;http://www.somewhere-else.com/page/&quot;)
</code></pre><p>限制：</p>
<ul>
<li>不能使用setRequestHeader()</li>
<li>不能发送和接收cookie</li>
<li>getAllResponseHeaders()方法总会返回空字符串</li>
</ul>
<h3 id="Preflighted-Requests"><a href="#Preflighted-Requests" class="headerlink" title="Preflighted Requests"></a>Preflighted Requests</h3><p>使用透明服务器验证机制支持开发人员使用自定义的头部，GET和POST之外的方法</p>
<h3 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h3><p>将withCredentials属性设为true</p>
<h3 id="跨浏览器的CROS"><a href="#跨浏览器的CROS" class="headerlink" title="跨浏览器的CROS"></a>跨浏览器的CROS</h3><p> 先检测XHR是否支持CORS的最简单方式，然后检查是否存在withCredentials属性，再结合检测XDomainRequest对象是否存在</p>
<pre><code>function createCORSRequest(method, url){
    var xhr = new XMLHttpRequest();
    if(&quot;withCredentials&quot; in xhr){
        xhr.open(method,url,true)
    } else if(typeof XDomainRequest != &quot;undefined&quot;){
        xhr = new XDomainRequest();
        xhr.open(method,url)
    } else{
        xhr = null;
    }
    return xhr;
}
var request = createCORSRequest(&quot;get&quot;,&quot;http://www.somewhere-else.com/page/&quot;);
if(request){
    request.onload = function(){
        //对 request.responseText处理
    }
    request.send();
}
</code></pre><h3 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h3><h4 id="图像ping"><a href="#图像ping" class="headerlink" title="图像ping"></a>图像ping</h4><p>只能发送Get请求，无法访问响应文本，一般用于统计页面点击次数和动态广告曝光次数</p>
<pre><code>var image = new Image();
image.onload = iamge.onerror = function(){
    alert(&quot;done&quot;);
};
img.src = &quot;http://···&quot;
</code></pre><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>支持双向通信，无法保证安全可靠，无法确定请求是否失败</p>
<pre><code>http://···/?callback=handleResponse
function handleResponse(res){

}
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/16/css清除浮动-高度塌陷问题/" itemprop="url">
                css清除浮动-高度塌陷问题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-16T16:32:19+08:00" content="2015-09-16">
            2015-09-16
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/css/" itemprop="url" rel="index">
                  <span itemprop="name">css</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/16/css清除浮动-高度塌陷问题/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/16/css清除浮动-高度塌陷问题/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><code>参考 http://www.divcss5.com/jiqiao/j406.shtml</code></p>
<h2 id="浮动产生原因"><a href="#浮动产生原因" class="headerlink" title="浮动产生原因"></a>浮动产生原因</h2><p>一般浮动是什么情况呢？一般是一个盒子里使用了CSSfloat浮动属性，导致父级对象盒子不能被撑开，这样CSS float浮动就产生了。这个问题经常发生，特别是在我改写ecshop源代码的时候</p>
<p><img src="http://7xltvd.com1.z0.glb.clouddn.com/css1.png" alt="alt css浮动" title="浮动问题"></p>
<p>本来两个黑色对象盒子是在红色盒子内，因为对两个黑色盒子使用了float浮动，所以两个黑色盒子产生了浮动，导致红色盒子不能撑开，这样浮动就产生了。</p>
<h2 id="浮动产生负作用"><a href="#浮动产生负作用" class="headerlink" title="浮动产生负作用"></a>浮动产生负作用</h2><ul>
<li>背景不能显示<br>由于浮动产生，如果对父级设置了（CSS background背景）CSS背景颜色或CSS背景图片，而父级不能被撑开，所以导致CSS背景不能显示。</li>
<li>边框不能撑开<br>如上图中，如果父级设置了CSS边框属性（css border），由于子级里使用了float属性，产生浮动，父级不能被撑开，导致边框不能随内容而被撑开。</li>
<li>margin padding设置值不能正确显示<br>由于浮动导致父级子级之间设置了css padding、css margin属性的值不能正确表达。特别是上下边的padding和margin不能正确显示。</li>
</ul>
<p><strong><em>在 <a href="http://www.zhangxinxu.com/wordpress/?p=1287" target="_blank" rel="external">http://www.zhangxinxu.com/wordpress/?p=1287</a> 这位大神的博客中将float和absolute比作折翼的天使，和天使中的魔鬼，我觉得很准确</em></strong></p>
<h2 id="css解决浮动，清除浮动方法"><a href="#css解决浮动，清除浮动方法" class="headerlink" title="css解决浮动，清除浮动方法"></a>css解决浮动，清除浮动方法</h2><h3 id="对父级设置适合CSS高度，前提是对象内容高度要能确定并能计算好"><a href="#对父级设置适合CSS高度，前提是对象内容高度要能确定并能计算好" class="headerlink" title="对父级设置适合CSS高度，前提是对象内容高度要能确定并能计算好"></a>对父级设置适合CSS高度，前提是对象内容高度要能确定并能计算好</h3><blockquote>
<p>这种方法基本不考虑，违背文档流自由发展的原则，后期开发难度很大</p>
</blockquote>
<h3 id="clear-both清除浮动"><a href="#clear-both清除浮动" class="headerlink" title="clear:both清除浮动"></a>clear:both清除浮动</h3><pre><code>.clear{clear:both}
并添加到浮动div之后
</code></pre><p>缺点：会添加很多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦，这是坚决不能忍受的，不考虑</p>
<h3 id="父级div定义-overflow-hidden"><a href="#父级div定义-overflow-hidden" class="headerlink" title="父级div定义 overflow:hidden"></a>父级div定义 overflow:hidden</h3><blockquote>
<p>在IE6中还需要触发 hasLayout ，例如 zoom：1；</p>
</blockquote>
<pre><code>&lt;div style=&quot;overflow:hidden; *zoom:1;&quot;&gt;
</code></pre><p>优点：不存在结构和语义化问题，代码量极少</p>
<p>缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致中键失效。不建议使用了</p>
<h3 id="父元素设置-overflow：auto-属性"><a href="#父元素设置-overflow：auto-属性" class="headerlink" title="父元素设置 overflow：auto 属性"></a>父元素设置 overflow：auto 属性</h3><p>同上</p>
<p>缺点：多个嵌套后，firefox某些情况会造成内容全选；IE中mouseover造成宽度改变时会出现最外层模块有滚动条等，firefox早期版本会无故产生focus等</p>
<h3 id="父元素也设置浮动"><a href="#父元素也设置浮动" class="headerlink" title="父元素也设置浮动"></a>父元素也设置浮动</h3><blockquote>
<p>使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body，不推荐使用</p>
</blockquote>
<h3 id="父元素设置display-table"><a href="#父元素设置display-table" class="headerlink" title="父元素设置display:table"></a>父元素设置display:table</h3><p>优点：结构语义化完全正确，代码量极少</p>
<p>缺点：盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用</p>
<h3 id="after-zoom方法"><a href="#after-zoom方法" class="headerlink" title="after + zoom方法"></a>after + zoom方法</h3><p>先来简单讲讲after，所谓after，就是指标签的最后一个子元素的后面。于是呢，我们可以用CSS代码生成一个具有clear属性的元素，其中的关键样式就是content了。或许您从网上看到的content里面的内容是”.”一个点，我了很多次，貌似随便写什么东西都没有问题，比如content:’clear both’;没问题，或是content:’张鑫旭’也是ok的。于是有：</p>
<pre><code>.fix{zoom:1;}
 .fix:after{display:block; content:&apos;clear&apos;; clear:both; line-height:0; visibility:hidden;} 
</code></pre><p>这里的line-height:0写成height:0也是可以的。此方法可以说是综合起来最好的方法了，我都是用这个样式清除浮动的，不会影响任何其他样式，通用性强，覆盖面广，我很推荐哦。</p>
<p><em>由于IE6-7不支持:after，使用 zoom:1触发 hasLayout</em></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/16/http1/" itemprop="url">
                http学习笔记（一）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-16T10:01:53+08:00" content="2015-09-16">
            2015-09-16
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/http/" itemprop="url" rel="index">
                  <span itemprop="name">http</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/16/http1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/16/http1/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><code>参考 http://www.runoob.com/http/http-messages.html</code></p>
<h2 id="HTTP三点注意事项："><a href="#HTTP三点注意事项：" class="headerlink" title="HTTP三点注意事项："></a>HTTP三点注意事项：</h2><ul>
<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li>
<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ul>
<p><img src="http://7xltvd.com1.z0.glb.clouddn.com/http1.gif" alt="alt http1" title="HTTP协议通信流程"></p>
<h2 id="HTTP消息结构"><a href="#HTTP消息结构" class="headerlink" title="HTTP消息结构"></a>HTTP消息结构</h2><p>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。<br>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。<br>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。<br>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。<br>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p>
<h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="http://7xltvd.com1.z0.glb.clouddn.com/http1-2.png" alt="alt http1" title="客户端请求消息"></p>
<h3 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h3><p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。<br><img src="http://7xltvd.com1.z0.glb.clouddn.com/http1-3.jpg" alt="alt http1" title="服务器响应消息"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面实例是一点典型的使用GET来传递数据的实例：<br>客户端请求：</p>
<pre><code>GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
</code></pre><p>服务端响应:</p>
<pre><code>HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: &quot;34aa387-d-1568eb00&quot;
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain
</code></pre><p>输出结果：</p>
<pre><code>Hello World! My payload includes a trailing CRLF.
</code></pre><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<ul>
<li>GET 请求指定的页面信息，并返回实体主体。</li>
<li>HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>PUT 从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE  请求服务器删除指定的页面。</li>
<li>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS 允许客户端查看服务器的性能。</li>
<li>TRACE   回显服务器收到的请求，主要用于测试或诊断。</li>
</ul>
<h2 id="HTTP-响应头信息"><a href="#HTTP-响应头信息" class="headerlink" title="HTTP 响应头信息"></a>HTTP 响应头信息</h2><ul>
<li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li>
<li>Content-Encoding    <strong><em>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</em></strong></li>
<li>Content-Length  表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li>
<li>Content-Type    表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 </li>
<li>Date    当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li>
<li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li>
<li>Last-Modified   文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li>
<li>Location    表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li>
<li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)让浏览器读取指定的页面。" target="_blank" rel="external">http://host/path&quot;)让浏览器读取指定的页面。</a><br>注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href="http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。" target="_blank" rel="external">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a> </li>
</ul>
<p>注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。 </p>
<p>注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。<br>Server  服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</p>
<ul>
<li>Set-Cookie  设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</li>
<li>WWW-Authenticate    客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。<br>注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）</li>
</ul>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。<br>HTTP状态码的英文为HTTP Status Code。<br>下面是常见的HTTP状态码：</p>
<pre><code>200 - 请求成功
301 - 资源（网页等）被永久转移到其它URL
404 - 请求的资源（网页等）不存在
500 - 内部服务器错误
</code></pre><h3 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h3><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：<br>HTTP状态码分类</p>
<ul>
<li>1** 信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2** 成功，操作被成功接收并处理</li>
<li>3** 重定向，需要进一步的操作以完成请求</li>
<li>4** 客户端错误，请求包含语法错误或无法完成请求</li>
<li>5** 服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<h3 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表:"></a>HTTP状态码列表:</h3><ul>
<li>100 Continue    继续。客户端应继续其请求</li>
<li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</li>
<li>200 OK  请求成功。一般用于GET与POST请求</li>
<li>201 Created 已创建。成功请求并创建了新的资源</li>
<li>202 Accepted    已接受。已经接受请求，但未处理完成</li>
<li>203 Non-Authoritative Information   非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</li>
<li>204 No Content  无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li>
<li>205 Reset Content   重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li>
<li>206 Partial Content 部分内容。服务器成功处理了部分GET请求</li>
<li>300 Multiple Choices    多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li>
<li>301 Moved Permanently   永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>
<li>302 Found   临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li>
<li>303 See Other   查看其它地址。与301类似。使用GET和POST请求查看</li>
<li>304 Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>
<li>305 Use Proxy   使用代理。所请求的资源必须通过代理访问</li>
<li>306 Unused  已经被废弃的HTTP状态码</li>
<li>307 Temporary Redirect  临时重定向。与302类似。使用GET请求重定向</li>
<li>400 Bad Request 客户端请求的语法错误，服务器无法理解</li>
<li>401 Unauthorized    请求要求用户的身份认证</li>
<li>402 Payment Required    保留，将来使用</li>
<li>403 Forbidden   服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li>404 Not Found   服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li>
<li>405 Method Not Allowed  客户端请求中的方法被禁止</li>
<li>406 Not Acceptable  服务器无法根据客户端请求的内容特性完成请求</li>
<li>407 Proxy Authentication Required   请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li>
<li>408 Request Time-out    服务器等待客户端发送的请求时间过长，超时</li>
<li>409 Conflict    服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</li>
<li>410 Gone    客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</li>
<li>411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息</li>
<li>412 Precondition Failed 客户端请求信息的先决条件错误</li>
<li>413 Request Entity Too Large    由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</li>
<li>414 Request-URI Too Large   请求的URI过长（URI通常为网址），服务器无法处理</li>
<li>415 Unsupported Media Type  服务器无法处理请求附带的媒体格式</li>
<li>416 Requested range not satisfiable 客户端请求的范围无效</li>
<li>417 Expectation Failed  服务器无法满足Expect的请求头信息</li>
<li>500 Internal Server Error   服务器内部错误，无法完成请求</li>
<li>501 Not Implemented 服务器不支持请求的功能，无法完成请求</li>
<li>502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</li>
<li>503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li>
<li>504 Gateway Time-out    充当网关或代理的服务器，未及时从远端服务器获取请求</li>
<li>505 HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理</li>
</ul>
<h2 id="HTTP-content-type"><a href="#HTTP-content-type" class="headerlink" title="HTTP content-type"></a>HTTP content-type</h2><p>Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因。</p>
<h3 id="HTTP-content-type-对照表"><a href="#HTTP-content-type-对照表" class="headerlink" title="HTTP content-type 对照表"></a>HTTP content-type 对照表</h3><p>下面直接给出链接，需要去查一下就好<br><a href="http://www.runoob.com/http/http-content-type.html" target="_blank" rel="external">http://www.runoob.com/http/http-content-type.html</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/14/js阻塞与非阻塞实践/" itemprop="url">
                js阻塞与非阻塞实践
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-14T14:24:19+08:00" content="2015-09-14">
            2015-09-14
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/js/" itemprop="url" rel="index">
                  <span itemprop="name">js</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/14/js阻塞与非阻塞实践/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/14/js阻塞与非阻塞实践/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><code>参考 http://www.nodebeginner.org/index-zh-cn.html#a-basic-http-server</code></p>
<h2 id="阻塞与非阻塞定义"><a href="#阻塞与非阻塞定义" class="headerlink" title="阻塞与非阻塞定义"></a>阻塞与非阻塞定义</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>《node.js开发指南》是这样定义的：线程在执行中如果遇到（I/O 操作）如磁盘读写或网络通信，通常要耗费较长的时间，这时操作系统会剥夺这个线程的 CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为 阻塞。当 I/O 操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种 I/O 模式就是通常的同步式 I/O（Synchronous I/O）或阻塞式 I/O（Blocking I/O）。</p>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>非阻塞是这样定义的，当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成 I/O 操作时，以事件的形式通知执行 I/O 操作的线程，线程会在特定时候处理这个事件。</p>
<h3 id="nodejs实践"><a href="#nodejs实践" class="headerlink" title="nodejs实践"></a>nodejs实践</h3><ul>
<li>编写server对服务器进行创建，并对req.url进行操作</li>
<li>编写router路由模块，对路径进行处理</li>
<li>编写requestHandler进行请求路由操作</li>
</ul>
<h3 id="进行阻塞操作"><a href="#进行阻塞操作" class="headerlink" title="进行阻塞操作"></a>进行阻塞操作</h3><p>将requestHandlers.js修改成如下形式：</p>
<pre><code>function start() {
  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);

  function sleep(milliSeconds) {
    var startTime = new Date().getTime();
    while (new Date().getTime() &lt; startTime + milliSeconds);
  }

  sleep(10000);
  return &quot;Hello Start&quot;;
}

function upload() {
  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);
  return &quot;Hello Upload&quot;;
}

exports.start = start;
exports.upload = upload;
</code></pre><p>上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。<br>（当然了，这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比方说一些长时间的计算操作等。）</p>
<p>接下来就让我们来看看，我们的改动带来了哪些变化。</p>
<p>如往常一样，我们先要重启下服务器。为了看到效果，我们要进行一些相对复杂的操作（跟着我一起做）： 首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href="http://localhost:8888/start，" target="_blank" rel="external">http://localhost:8888/start，</a> 但是先不要打开它！</p>
<p>在第二个浏览器窗口的地址栏中输入<a href="http://localhost:8888/upload，" target="_blank" rel="external">http://localhost:8888/upload，</a> 同样的，先不要打开它！</p>
<p>接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。</p>
<p>注意，发生了什么： /start URL加载花了10秒，这和我们预期的一样。但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！</p>
<p>这到底是为什么呢？原因就是start()包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。</p>
<p>这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。</p>
<p>这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，我们应该要充分利用这一点 —— 尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。</p>
<p>然而，要用非阻塞操作，我们需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。</p>
<p>对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</p>
<h3 id="非阻塞操作"><a href="#非阻塞操作" class="headerlink" title="非阻塞操作"></a>非阻塞操作</h3><p>修改requestHandler<br>    var exec = require(“child_process”).exec;</p>
<pre><code>function start() {
  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);
  var content = &quot;empty&quot;;

  exec(&quot;ls -lah&quot;, function (error, stdout, stderr) {
    content = stdout;
  });

  return content;
}

function upload() {
  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);
  return &quot;Hello Upload&quot;;
}

exports.start = start;
exports.upload = upload;
</code></pre><p>上述代码中，我们引入了一个新的Node.js模块，child_process。之所以用它，是为了实现一个既简单又实用的非阻塞操作：exec()。</p>
<p>exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。</p>
<p>上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。</p>
<p>和往常一样，我们启动服务器，然后访问“<a href="http://localhost:8888/start”" target="_blank" rel="external">http://localhost:8888/start”</a> 。</p>
<p>之后会载入一个漂亮的web页面，其内容为“empty”。怎么回事？</p>
<p>这个时候，你可能大致已经猜到了，exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使我们的应用停下来等待该操作。</p>
<p>（如果想要证明这一点，可以将“ls -lah”换成比如“find /”这样更耗时的操作来效果）。</p>
<p>然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？</p>
<p>好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。</p>
<p>问题就在于，为了进行非阻塞工作，exec()使用了回调函数。</p>
<p>在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数：</p>
<pre><code>function (error, stdout, stderr) {
  content = stdout;
}
</code></pre><p>现在就到了问题根源所在了：我们的代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行 return content ；在这个时候，content仍然是“empty”，因为传递给exec()的回调函数还未执行到——因为exec()的操作是异步的。</p>
<p>我们这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到 —— 不过，不管怎么说它还是异步的。</p>
<p>为了让效果更加明显，我们想象一个更耗时的命令： “find /”，它在我机器上需要执行1分钟左右的时间，然而，尽管在请求处理程序中，我把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。</p>
<p>那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？</p>
<p>好，了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。</p>
<h2 id="以非阻塞操作进行请求响应"><a href="#以非阻塞操作进行请求响应" class="headerlink" title="以非阻塞操作进行请求响应"></a>以非阻塞操作进行请求响应</h2><p>刚刚提到了这样一个短语 —— “正确的方式”。而事实上通常“正确的方式”一般都不简单。</p>
<p>不过，用Node.js就有这样一种实现方案： 函数传递。下面就让我们来具体看看如何实现。</p>
<p>到目前为止，我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</p>
<p>现在我们采用如下这种新的实现方式：相对采用将内容传递给服务器的方式，我们这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。</p>
<p>原理就是如此，接下来让我们来一步步实现这种方案。</p>
<p>先从server.js开始：</p>
<pre><code>var http = require(&quot;http&quot;);
var url = require(&quot;url&quot;);

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);

    route(handle, pathname, response);
  }

  http.createServer(onRequest).listen(8888);
  console.log(&quot;Server has started.&quot;);
}

exports.start = start;
</code></pre><p>相对此前从route()函数获取返回值的做法，这次我们将response对象作为第三个参数传递给route()函数，并且，我们将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。</p>
<p>下面就来看看我们的router.js:</p>
<pre><code>function route(handle, pathname, response) {
  console.log(&quot;About to route a request for &quot; + pathname);
  if (typeof handle[pathname] === &apos;function&apos;) {
    handle[pathname](response);
  } else {
    console.log(&quot;No request handler found for &quot; + pathname);
    response.writeHead(404, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(&quot;404 Not found&quot;);
    response.end();
  }
}

exports.route = route;
</code></pre><p>同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。</p>
<p>如果没有对应的请求处理器处理，我们就直接返回“404”错误。</p>
<p>最后，我们将requestHandler.js修改为如下形式：</p>
<pre><code>var exec = require(&quot;child_process&quot;).exec;

function start(response) {
  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);

  exec(&quot;ls -lah&quot;, function (error, stdout, stderr) {
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
    response.write(stdout);
    response.end();
  });
}

function upload(response) {
  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello Upload&quot;);
  response.end();
}

exports.start = start;
exports.upload = upload;
</code></pre><p>我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。</p>
<p>start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。</p>
<p>这时再次我们启动应用（node index.js），一切都会工作的很好。</p>
<p>如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式：</p>
<p>var exec = require(“child_process”).exec;</p>
<pre><code>function start(response) {
  console.log(&quot;Request handler &apos;start&apos; was called.&quot;);

  exec(&quot;find /&quot;,
    { timeout: 10000, maxBuffer: 20000*1024 },
    function (error, stdout, stderr) {
      response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
      response.write(stdout);
      response.end();
    });
}

function upload(response) {
  console.log(&quot;Request handler &apos;upload&apos; was called.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello Upload&quot;);
  response.end();
}

exports.start = start;
exports.upload = upload;
</code></pre><p>这样一来，当请求<a href="http://localhost:8888/start的时候，会花10秒钟的时间才载入，而当请求http://localhost:8888/upload的时候，会立即响应，纵然这个时候/start响应还在处理中。" target="_blank" rel="external">http://localhost:8888/start的时候，会花10秒钟的时间才载入，而当请求http://localhost:8888/upload的时候，会立即响应，纵然这个时候/start响应还在处理中。</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/09/lazyload/" itemprop="url">
                lazyload（懒加载）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-09T17:36:13+08:00" content="2015-09-09">
            2015-09-09
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/js/" itemprop="url" rel="index">
                  <span itemprop="name">js</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/09/lazyload/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/09/lazyload/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于坑爹的老板以及设计师都不愿意降低图片尺寸，或者压缩图片，苦了我们这些写代码的<br>首先用gulp压缩图片大小，然后就要用到lazyload了</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p><code>转载自： http://www.csdn.net/article/2013-10-15/2817187-3-ways-preload-images-css-javascript-ajax</code><br>图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。</p>
<h3 id="用CSS和JavaScript实现预加载"><a href="#用CSS和JavaScript实现预加载" class="headerlink" title="用CSS和JavaScript实现预加载"></a>用CSS和JavaScript实现预加载</h3><pre><code>#preload-01 { background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; }
#preload-02 { background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px; }
#preload-03 { background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px; }
</code></pre><p>将这三个ID选择器应用到(X)HTML元素中，我们便可通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它们在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript</p>
<p>该方法虽然高效，但仍有改进余地。使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。代码如下：</p>
<pre><code>// better image preloading @ &lt;a href=&quot;http://perishablepress.com/press/2009/12/28/3-ways-preload-images-css-javascript-ajax/&quot;&gt;http://perishablepress.com/press/2009/12/28/3-ways-preload-images-css-javascript-ajax/&lt;/a&gt;
function preloader() {
    if (document.getElementById) {
        document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(http://domain.tld/image-01.png) no-repeat -9999px -9999px&quot;;
        document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(http://domain.tld/image-02.png) no-repeat -9999px -9999px&quot;;
        document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(http://domain.tld/image-03.png) no-repeat -9999px -9999px&quot;;
    }
}
function addLoadEvent(func) {
    var oldonload = window.onload;
    if (typeof window.onload != &apos;function&apos;) {
        window.onload = func;
    } else {
        window.onload = function() {
            if (oldonload) {
                oldonload();
            }
            func();
        }
    }
}
addLoadEvent(preloader);
</code></pre><p>在该脚本的第一部分，我们获取使用类选择器的元素，并为其设置了background属性，以预加载不同的图片。</p>
<p>该脚本的第二部分，我们使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。</p>
<p>如果JavaScript无法在用户的浏览器中正常运行，会发生什么？很简单，图片不会被预加载，当页面调用图片时，正常显示即可。</p>
<h3 id="仅使用JavaScript实现预加载"><a href="#仅使用JavaScript实现预加载" class="headerlink" title="仅使用JavaScript实现预加载"></a>仅使用JavaScript实现预加载</h3><p>上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。下面将提供两种这样的预加载方法，它们可以很漂亮地工作于所有现代浏览器之上。</p>
<p>####JavaScript代码段1<br>只需简单编辑、加载所需要图片的路径与名称即可，很容易实现：</p>
<pre><code>&lt;div class=&quot;hidden&quot;&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        &lt;!--//--&gt;&lt;![CDATA[//&gt;&lt;!--
            var images = new Array()
            function preload() {
                for (i = 0; i &lt; preload.arguments.length; i++) {
                    images[i] = new Image()
                    images[i].src = preload.arguments[i]
                }
            }
            preload(
                &quot;http://domain.tld/gallery/image-001.jpg&quot;,
                &quot;http://domain.tld/gallery/image-002.jpg&quot;,
                &quot;http://domain.tld/gallery/image-003.jpg&quot;
            )
        //--&gt;&lt;!]]&gt;
    &lt;/script&gt;
&lt;/div&gt;
</code></pre><h4 id="JavaScript代码段2"><a href="#JavaScript代码段2" class="headerlink" title="JavaScript代码段2"></a>JavaScript代码段2</h4><pre><code>&lt;div class=&quot;hidden&quot;&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        &lt;!--//--&gt;&lt;![CDATA[//&gt;&lt;!--
            if (document.images) {
                img1 = new Image();
                img2 = new Image();
                img3 = new Image();
                img1.src = &quot;http://domain.tld/path/to/image-001.gif&quot;;
                img2.src = &quot;http://domain.tld/path/to/image-002.gif&quot;;
                img3.src = &quot;http://domain.tld/path/to/image-003.gif&quot;;
            }
        //--&gt;&lt;!]]&gt;
    &lt;/script&gt;
&lt;/div&gt;
</code></pre><p>正如所看见，每加载一个图片都需要创建一个变量，如“img1 = new Image();”，及图片源地址声明，如“img3.src = “../path/to/image-003.gif”;”。参考该模式，你可根据需要加载任意多的图片。</p>
<p>我们又对该方法进行了改进。将该脚本封装入一个函数中，并使用 addLoadEvent（），延迟预加载时间，直到页面加载完毕。</p>
<pre><code>function preloader() {
if (document.images) {
    var img1 = new Image();
    var img2 = new Image();
    var img3 = new Image();
    img1.src = &quot;http://domain.tld/path/to/image-001.gif&quot;;
    img2.src = &quot;http://domain.tld/path/to/image-002.gif&quot;;
    img3.src = &quot;http://domain.tld/path/to/image-003.gif&quot;;
}
}
function addLoadEvent(func) {
    var oldonload = window.onload;
    if (typeof window.onload != &apos;function&apos;) {
        window.onload = func;
    } else {
        window.onload = function() {
            if (oldonload) {
                oldonload();
            }
            func();
        }
    }
}
addLoadEvent(preloader);
</code></pre><h3 id="使用Ajax实现预加载"><a href="#使用Ajax实现预加载" class="headerlink" title="使用Ajax实现预加载"></a>使用Ajax实现预加载</h3><p>上面所给出的方法似乎不够酷，那现在来看一个使用Ajax实现图片预加载的方法。该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于JavaScript和CSS的加载不会影响到当前页面。该方法简洁、高效。</p>
<pre><code>window.onload = function() {
    setTimeout(function() {
        // XHR to request a JS and a CSS
        var xhr = new XMLHttpRequest();
        xhr.open(&apos;GET&apos;, &apos;http://domain.tld/preload.js&apos;);
        xhr.send(&apos;&apos;);
        xhr = new XMLHttpRequest();
        xhr.open(&apos;GET&apos;, &apos;http://domain.tld/preload.css&apos;);
        xhr.send(&apos;&apos;);
        // preload image
        new Image().src = &quot;http://domain.tld/preload.png&quot;;
    }, 1000);
};
</code></pre><p>上面代码预加载了“preload.js”、“preload.css”和“preload.png”。1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。</p>
<p>下面，我们看看如何用JavaScript来实现该加载过程：</p>
<pre><code>window.onload = function() {

    setTimeout(function() {

        // reference to &lt;head&gt;
        var head = document.getElementsByTagName(&apos;head&apos;)[0];

        // a new CSS
        var css = document.createElement(&apos;link&apos;);
        css.type = &quot;text/css&quot;;
        css.rel  = &quot;stylesheet&quot;;
        css.href = &quot;http://domain.tld/preload.css&quot;;

        // a new JS
        var js  = document.createElement(&quot;script&quot;);
        js.type = &quot;text/javascript&quot;;
        js.src  = &quot;http://domain.tld/preload.js&quot;;

        // preload JS and CSS
        head.appendChild(css);
        head.appendChild(js);

        // preload image
        new Image().src = &quot;http://domain.tld/preload.png&quot;;

    }, 1000);

};
</code></pre><h2 id="lazyload（可以参考网站-http-www-appelsiini-net-projects-lazyload）"><a href="#lazyload（可以参考网站-http-www-appelsiini-net-projects-lazyload）" class="headerlink" title="lazyload（可以参考网站 http://www.appelsiini.net/projects/lazyload）"></a>lazyload（可以参考网站 <a href="http://www.appelsiini.net/projects/lazyload）" target="_blank" rel="external">http://www.appelsiini.net/projects/lazyload）</a></h2><p>懒加载在一些大型的网站中见到的比较多，因为网站考虑到性能、流量及用户体验方面的问题，在用户点击开网站的首页的时候，网站想尽可能的显示更多的信息给用户，又要考虑到服务器的性能的问题，还不能让用户等待的时间过长，所以这里就出现了图片的懒加载。图片的懒加载可以让用户按照需求从服务器上加载图片，这样即节省了用户在代开首页时的等待时间，也节省了服务器的流量，所以是一个好的选择。懒加载的基本思路就是不给img标签写src属性，而是写到一个后边可以操作的属性中，如data-src中，然后在后边需要加载的时候，加载图片，图片地址写到src中。</p>
<h3 id="lazyload实现方法"><a href="#lazyload实现方法" class="headerlink" title="lazyload实现方法"></a>lazyload实现方法</h3><ul>
<li>1.载入jquery，然后载入jquery.lazyload</li>
<li>2.编写img标签，必须有的属性有data-original=”[image_href]”，height和width也必须有，最好在src中写一个小像素的背景</li>
<li>3.编写script标签 </li>
</ul>
<p>具体的其他方法可以去参考网上的文档    </p>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><ul>
<li><p>设置一个定时器，计算每张图片是否会随着滚动条的滚动，而出现在视口（也就是浏览器中的 展现网站的空白部分 ）中；</p>
</li>
<li><p>为img标签设置一个暂存图片URL的自定义属性（例如loadpic），当图片出现在视口时，再将loadpic的值赋给图片的src属性；</p>
</li>
</ul>
<p>##实现方法</p>
<p>原生js方法</p>
<pre><code>var imgs = document.getElementsByTagName(&apos;img&apos;);
 // 获取视口高度与滚动条的偏移量
 function lazyload(){
   var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
   var viewportSize = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
   for(var i=0; i&lt;imgs.length; i++) {
     var x =scrollTop+viewportSize-imgs[i].offsetTop;
     if(x&gt;0){
       imgs[i].src = imgs[i].getAttribute(&apos;loadpic&apos;);   
     }
   }
 }
 setInterval(lazyload,1000);
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/09/gulp1/" itemprop="url">
                gulp1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-09T14:05:26+08:00" content="2015-09-09">
            2015-09-09
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端工具/" itemprop="url" rel="index">
                  <span itemprop="name">前端工具</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/09/gulp1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/09/gulp1/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><em>*</em>最近大概看了一下gulp觉得还是很不错的，从网上找了例子，加自己的一些东拼西凑，就把一个项目的gulp配置完成了</p>
<hr>
<h2 id="列出配置的package-json"><a href="#列出配置的package-json" class="headerlink" title="列出配置的package.json"></a>列出配置的package.json</h2><pre><code>{
  &quot;name&quot;: &quot;gulp_demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;My gulp example for project&quot;,
  &quot;main&quot;: &quot;gulpfile.js&quot;,
  &quot;dependencies&quot;: {
    &quot;gulp&quot;: &quot;^3.9.0&quot;,
    &quot;gulp-imagemin&quot;: &quot;^2.3.0&quot;,
    &quot;gulp-less&quot;: &quot;^3.0.3&quot;,
    &quot;gulp-minify-css&quot;: &quot;^1.2.1&quot;,
    &quot;gulp-uglify&quot;: &quot;^1.4.0&quot;,
    &quot;gulp-watch-path&quot;: &quot;^0.1.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;amd-optimize&quot;: &quot;^0.6.0&quot;,
    &quot;colors&quot;: &quot;^1.1.2&quot;,
    &quot;gulp&quot;: &quot;^3.9.0&quot;,
    &quot;gulp-autoprefixer&quot;: &quot;^3.0.1&quot;,
    &quot;gulp-cache&quot;: &quot;^0.3.0&quot;,
    &quot;gulp-concat&quot;: &quot;^2.6.0&quot;,
    &quot;gulp-imagemin&quot;: &quot;^2.3.0&quot;,
    &quot;gulp-less&quot;: &quot;^3.0.3&quot;,
    &quot;gulp-minify-css&quot;: &quot;^1.2.1&quot;,
    &quot;gulp-sourcemaps&quot;: &quot;^1.5.2&quot;,
    &quot;gulp-uglify&quot;: &quot;^1.4.0&quot;,
    &quot;gulp-util&quot;: &quot;^3.0.6&quot;,
    &quot;gulp-watch-path&quot;: &quot;^0.1.0&quot;,
    &quot;imagemin-pngquant&quot;: &quot;^4.2.0&quot;,
    &quot;stream-combiner2&quot;: &quot;^1.0.2&quot;
  },
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;zhanfang&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre><h2 id="解析安装的模块"><a href="#解析安装的模块" class="headerlink" title="解析安装的模块"></a>解析安装的模块</h2><pre><code>//基础gulp
var gulp = require(&apos;gulp&apos;)
//gulp的工具，主要用来打印错误信息
var gutil = require(&apos;gulp-util&apos;)
//压缩js代码
var uglify = require(&apos;gulp-uglify&apos;)
//监听代码变化
var watchPath = require(&apos;gulp-watch-path&apos;)
//帮助调试
var sourcemaps = require(&apos;gulp-sourcemaps&apos;)
//压缩css代码
var minifycss = require(&apos;gulp-minify-css&apos;)
//自动补全功能，主要针对css
//eg: display:flex
//=&gt;: -webkit-display:flex;-moz-display:flex;display-flex
var autoprefixer = require(&apos;gulp-autoprefixer&apos;)
//编译less文件
var less = require(&apos;gulp-less&apos;)
//压缩image
var imagemin = require(&apos;gulp-imagemin&apos;)
//这个主要是保证代码编写错误时，gulp不退出，并捕获到错误代码
var combiner = require(&apos;stream-combiner2&apos;)

//深度压缩png图片
var pngquant = require(&apos;imagemin-pngquant&apos;);
//利用缓存保证没有修改的不用重新压缩或者编译
var cache = require(&apos;gulp-cache&apos;);
</code></pre><h2 id="gulpfile"><a href="#gulpfile" class="headerlink" title="gulpfile"></a>gulpfile</h2><pre><code>var handlerError = function (err) {
    var colors = gutil.colors;
    console.log(&apos;\n&apos;);
    gutil.log(colors.red(&apos;ERROR!&apos;));
    gutil.log(&quot;Filename: &quot;+ colors.red(err.fileName));
    gutil.log(&apos;linenum: &apos;+ colors.red(err.lineNumber));
    gutil.log(&apos;message: &apos; + err.message);
    gutil.log(&apos;plugin: &apos; + colors.yellow(err.plugins));
}

gulp.task(&apos;watchjs&apos;, function () {
    gulp.watch(&apos;public/**/*.js&apos;, function (event) {
        var paths = watchPath(event,&apos;public/&apos;,&apos;dist/&apos;);
        /*
         paths {srcPath: &apos;src/file.js&apos;,
         srcDir: &apos;src/&apos;,
         distPath: &apos;dist/file.node&apos;,
         distDir: &apos;dist/&apos;,
         srcFilename: &apos;file.js&apos;,
         distFilename: &apos;file.node&apos; }
         */
        gutil.log(gutil.colors.green(event.type) + &apos; &apos; + paths.srcPath);
        gutil.log(&apos;Dist &apos; + paths.distPath);

        //帮助解决语法错误
        var combined = combiner.obj([
            gulp.src(paths.srcPath),
            sourcemaps.init(),
            uglify(),
            sourcemaps.write(&apos;./&apos;),
            gulp.dest(paths.distDir)]);
        combined.on(&apos;error&apos;,handlerError);
    });
});

gulp.task(&apos;watchcss&apos;, function () {
    gulp.watch(&apos;public/css/**/*.css&apos;, function (event) {
        var paths = watchPath(event, &apos;public/&apos;, &apos;dist/&apos;)

        gutil.log(gutil.colors.green(event.type) + &apos; &apos; + paths.srcPath)
        gutil.log(&apos;Dist &apos; + paths.distPath)

        var combined = combiner.obj(
            gulp.src(paths.srcPath),
            sourcemaps.init(),
            autoprefixer({
                browsers: &apos;last 2 versions&apos;
            }),
            minifycss(),
            sourcemaps.write(&apos;./&apos;),
            gulp.dest(paths.distDir)
        );
        combined.on(&apos;error&apos;,handlerError);
    })
})

gulp.task(&apos;watchless&apos;, function () {
    gulp.watch(&apos;public/less/**/*.less&apos;, function (event) {
        var paths = watchPath(event, &apos;public/less/&apos;, &apos;dist/css/&apos;)

        gutil.log(gutil.colors.green(event.type) + &apos; &apos; + paths.srcPath)
        gutil.log(&apos;Dist &apos; + paths.distPath)

        //// 1. 找到 less 文件
        //gulp.src(paths.srcPath)
        //    // 2. 编译为css
        //    .pipe(less())
        //    // 3. 另存文件
        //    .pipe(gulp.dest(&apos;public/css&apos;))

        var combined = combiner.obj([
            gulp.src(paths.srcPath),
            less(),
            gulp.dest(&apos;public/css&apos;)
        ])
        combined.on(&apos;error&apos;, handlerError)
    })
})

gulp.task(&apos;watchcopy&apos;, function () {
    gulp.watch(&apos;public/fonts/**/*&apos;, function (event) {
        var paths = watchPath(event)

        gutil.log(gutil.colors.green(event.type) + &apos; &apos; + paths.srcPath)
        gutil.log(&apos;Dist &apos; + paths.distPath)

        gulp.src(paths.srcPath)
            .pipe(gulp.dest(paths.distDir))
    })
})


gulp.task(&apos;watchimage&apos;, function () {
    gulp.watch(&apos;public/img/**/*&apos;, function (event) {
        var paths = watchPath(event,&apos;public/&apos;,&apos;dist/&apos;)

        gutil.log(gutil.colors.green(event.type) + &apos; &apos; + paths.srcPath)
        gutil.log(&apos;Dist &apos; + paths.distPath)

        gulp.src(paths.srcPath)
            .pipe(imagemin({
                progressive: true
            }))
            .pipe(gulp.dest(paths.distDir))
    })
})

gulp.task(&apos;uglifyjs&apos;, function () {
    var combined = combiner.obj([
        gulp.src(&apos;public/js/**/*.js&apos;),
        sourcemaps.init(),
        uglify(),
        sourcemaps.write(&apos;./&apos;),
        gulp.dest(&apos;dist/js/&apos;)]);
    combined.on(&apos;error&apos;, handlerError)
});
//有时我们也需要一次编译所有 css 文件。可以配置 minifyss 任务
gulp.task(&apos;minifycss&apos;, function () {
    var combined = combiner.obj([
        gulp.src(&apos;public/css/**/*.css&apos;),
        sourcemaps.init(),
        autoprefixer({
            browsers: &apos;last 2 versions&apos;
        }),
        minifycss(),
        sourcemaps.write(&apos;./&apos;),
        gulp.dest(&apos;dist/css/&apos;)]);
    combined.on(&apos;error&apos;, handlerError)
})

gulp.task(&apos;lesscss&apos;, function () {

    var combined = combiner.obj([
        gulp.src(&apos;public/less/**/*.less&apos;),
        less(),
        gulp.dest(&apos;public/css&apos;)
    ]);
    combined.on(&apos;error&apos;,handlerError);
    //
    //// 1. 找到 less 文件
    //gulp.src(&apos;public/less/**/*.less&apos;)
    //    // 2. 编译为css
    //    .pipe(less())
    //    // 3. 另存文件
    //    .pipe(gulp.dest(&apos;public/css&apos;))
})

gulp.task(&apos;image&apos;, function () {
    var combined = combiner.obj([
        gulp.src(&apos;public/img/**/*&apos;),
        imagemin({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染
            multipass: true, //类型：Boolean 默认：false 多次优化svg直到完全优化
            svgoPlugins: [{removeViewBox: false}],//不要移除svg的viewbox属性
            use: [pngquant()] //使用pngquant深度压缩png图片的imagemin插件
        }),
        gulp.dest(&apos;dist/images&apos;)
    ])
    combined.on(&apos;error&apos;,handlerError);
})

gulp.task(&apos;copy&apos;, function () {
    gulp.src(&apos;public/fonts/**/*&apos;)
        .pipe(gulp.dest(&apos;dist/fonts/&apos;))
})

gulp.task(&apos;default&apos;,[&apos;image&apos;,&apos;uglifyjs&apos;,&apos;lesscss&apos;,&apos;minifycss&apos;,&apos;copy&apos;,
    &apos;watchjs&apos;,&apos;watchcss&apos;,&apos;watchimage&apos;,&apos;watchcopy&apos;,&apos;watchless&apos; ]);
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/05/js模块化3/" itemprop="url">
                Javascript模块化编程（三）：require.js的用法(转载阮一峰)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-05T17:25:58+08:00" content="2015-09-05">
            2015-09-05
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/js/" itemprop="url" rel="index">
                  <span itemprop="name">js</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/05/js模块化3/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/05/js模块化3/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>这个系列的第一部分和第二部分，介绍了Javascript模块原型和理论概念，今天介绍如何将它们用于实战。<br>我采用的是一个非常流行的库require.js。</p>
<h2 id="一、为什么要用require-js？"><a href="#一、为什么要用require-js？" class="headerlink" title="一、为什么要用require.js？"></a>一、为什么要用require.js？</h2><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。</p>
<pre><code>&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;
</code></pre><p>这段代码依次加载多个js文件。</p>
<p>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p>
<p>require.js的诞生，就是为了解决这两个问题：
　　</p>
<ol>
<li>实现js文件的异步加载，避免网页失去响应；</li>
<li>管理模块之间的依赖性，便于代码的编写和维护。</li>
</ol>
<h2 id="二、require-js的加载"><a href="#二、require-js的加载" class="headerlink" title="二、require.js的加载"></a>二、require.js的加载</h2><p>使用require.js的第一步，是先去官方网站下载最新版本。<br>下载后，假定把它放在js子目录下面，就可以加载了。</p>
<pre><code>&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;
</code></pre><p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<pre><code>&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;
</code></pre><p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。<br>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p>
<pre><code>&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;
</code></pre><p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p>
<p>##三、主模块的写法<br>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。<br>下面就来看，怎么写main.js。<br>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line">alert(<span class="string">"加载成功！"</span>);</div></pre></td></tr></table></figure>
<p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>, <span class="string">'moduleC'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA, moduleB, moduleC</span>)</span>&#123;</div><div class="line">	<span class="comment">// some code here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。<br>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。<br>下面，我们看一个实际的例子。<br>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'jquery'</span>, <span class="string">'underscore'</span>, <span class="string">'backbone'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$, _, Backbone</span>)</span>&#123;</div><div class="line">	<span class="comment">// some code here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p>
<h2 id="四、模块的加载"><a href="#四、模块的加载" class="headerlink" title="四、模块的加载"></a>四、模块的加载</h2><p>上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。<br>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">	<span class="attr">paths</span>: &#123;</div><div class="line">		<span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,</div><div class="line">		<span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</div><div class="line">		<span class="string">"backbone"</span>: <span class="string">"backbone.min"</span></div><div class="line">		&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">	<span class="attr">paths</span>: &#123;</div><div class="line">		<span class="string">"jquery"</span>: <span class="string">"lib/jquery.min"</span>,</div><div class="line">		<span class="string">"underscore"</span>: <span class="string">"lib/underscore.min"</span>,</div><div class="line">		<span class="string">"backbone"</span>: <span class="string">"lib/backbone.min"</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>另一种则是直接改变基目录（baseUrl）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">	<span class="attr">baseUrl</span>: <span class="string">"js/lib"</span>,</div><div class="line">	<span class="attr">paths</span>: &#123;</div><div class="line">		<span class="string">"jquery"</span>: <span class="string">"jquery.min"</span>,</div><div class="line">		<span class="string">"underscore"</span>: <span class="string">"underscore.min"</span>,</div><div class="line">		<span class="string">"backbone"</span>: <span class="string">"backbone.min"</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">	<span class="attr">paths</span>: &#123;</div><div class="line">		<span class="string">"jquery"</span>: <span class="string">"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min"</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p>
<h2 id="五、AMD模块的写法"><a href="#五、AMD模块的写法" class="headerlink" title="五、AMD模块的写法"></a>五、AMD模块的写法</h2><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。<br>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。<br>假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> x+y;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">add</span>: add</div><div class="line">	&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>加载方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// main.js</span></div><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</div><div class="line">	alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		myLib.doSomething();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">foo</span> : foo</div><div class="line">	&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p>
<h2 id="六、加载非规范的模块"><a href="#六、加载非规范的模块" class="headerlink" title="六、加载非规范的模块"></a>六、加载非规范的模块</h2><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。<br>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">	<span class="attr">shim</span>: &#123;</div><div class="line">		<span class="string">'underscore'</span>:&#123;</div><div class="line">			<span class="attr">exports</span>: <span class="string">'_'</span></div><div class="line">		&#125;,</div><div class="line">		<span class="string">'backbone'</span>: &#123;</div><div class="line">			<span class="attr">deps</span>: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</div><div class="line">    　　<span class="attr">exports</span>: <span class="string">'Backbone'</span></div><div class="line">    　&#125;</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。<br>比如，jQuery的插件可以这样定义：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">shim</span>: &#123;</div><div class="line">	<span class="string">'jquery.scroll'</span>: &#123;</div><div class="line">		<span class="attribute">deps</span>: [<span class="string">'jquery'</span>],</div><div class="line">  		<span class="attribute">exports</span>: <span class="string">'jQuery.fn.scroll'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="七、require-js插件"><a href="#七、require-js插件" class="headerlink" title="七、require.js插件"></a>七、require.js插件</h2><p>require.js还提供一系列插件，实现一些特定的功能。<br>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'domready!'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>)</span>&#123;</div><div class="line">   <span class="comment">// called once the DOM is ready</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>text和image插件，则是允许require.js加载文本和图片文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">define([</div><div class="line">	<span class="string">'text!review.txt'</span>,</div><div class="line">	<span class="string">'image!cat.jpg'</span></div><div class="line">	],</div><div class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">review,cat</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(review);</div><div class="line">		<span class="built_in">document</span>.body.appendChild(cat);</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>类似的插件还有json和mdown，用于加载json文件和markdown文件。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/05/js模块化2/" itemprop="url">
                Javascript模块化编程（二）：AMD规范(转载阮一峰)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-05T17:22:52+08:00" content="2015-09-05">
            2015-09-05
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/js/" itemprop="url" rel="index">
                  <span itemprop="name">js</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/05/js模块化2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/05/js模块化2/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>这个系列的第一部分介绍了Javascript模块的基本写法，今天介绍如何规范地使用模块。</p>
<p>##七、模块的规范<br>先想一想，为什么模块很重要？<br>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。<br>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。<br>目前，通行的Javascript模块规范共有两种：CommonJS和AMD。我主要介绍AMD，但是要先从CommonJS讲起。</p>
<p>##八、CommonJS<br>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。</p>
<p>这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。<br>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</div></pre></td></tr></table></figure></p>
<p>然后，就可以调用模块提供的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</div><div class="line">math.add(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>因为这个系列主要针对浏览器编程，不涉及node.js，所以对CommonJS就不多做介绍了。我们在这里只要知道，require()用于加载模块就行了。</p>
<p>##九、浏览器环境<br>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。<br>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</div><div class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。<br>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p>##十、AMD<br>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<br>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</div></pre></td></tr></table></figure></p>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</div><div class="line">　　　　math.add(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line">　　&#125;);</div><div class="line">math.add()</div></pre></td></tr></table></figure></p>
<p>与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。<br>目前，主要有两个Javascript库实现了AMD规范：require.js和curl.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/05/js模块化1/" itemprop="url">
                Javascript模块化编程（一）：模块的写法(转载自阮一峰)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-05T17:14:15+08:00" content="2015-09-05">
            2015-09-05
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/js/" itemprop="url" rel="index">
                  <span itemprop="name">js</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/05/js模块化1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/05/js模块化1/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>随着网站逐渐变成”互联网应用程序”，嵌入网页的Javascript代码越来越庞大，越来越复杂。</p>
<p>网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。</p>
<p>Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，Javascript不是一种模块化编程语言，它不支持”类”（class），更遑论”模块”（module）了。（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要很长时间才能投入实用。）</p>
<p>Javascript社区做了很多努力，在现有的运行环境中，实现”模块”的效果。本文总结了当前＂Javascript模块化编程＂的最佳实践，说明如何投入实用。虽然这不是初级教程，但是只要稍稍了解Javascript的基本语法，就能看懂。</p>
<p>##一、原始写法<br>模块就是实现特定功能的一组方法。<br>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。<br>    　<br>    　function m1(){<br>    　　　　//…<br>    　　}<br>    　　function m2(){<br>    　　　　//…<br>    　　}<br>上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。<br>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<p>##二、对象写法<br>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。<br>    　　<br>    var module1 = new Object({<br>    　　　　_count : 0,<br>    　　　　m1 : function (){<br>    　　　　　　//…<br>    　　　　},<br>    　　　　m2 : function (){<br>    　　　　　　//…<br>    　　　　}<br>    　　});<br>上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。<br>　　<br>    module1.m1();<br>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<pre><code>module1._count = 5;
</code></pre><p>##三、立即执行函数写法<br>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），可以达到不暴露私有成员的目的。<br>    　　<br>    var module1 = (function(){<br>    　　　　var _count = 0;<br>    　　　　var m1 = function(){<br>    　　　　　　//…<br>    　　　　};<br>    　　　　var m2 = function(){<br>    　　　　　　//…<br>    　　　　};<br>    　　　　return {<br>    　　　　　　m1 : m1,<br>    　　　　　　m2 : m2<br>    　　　　};<br>    　　})();<br>使用上面的写法，外部代码无法读取内部的_count变量。<br>　　console.info(module1._count); //undefined<br>module1就是Javascript模块的基本写法。下面，再对这种写法进行加工。</p>
<p>##四、放大模式<br>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。<br>    　　<br>    var module1 = (function (mod){<br>    　　　　mod.m3 = function () {<br>    　　　　　　//…<br>    　　　　};<br>    　　　　return mod;<br>    　　})(module1);<br>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</p>
<p>##五、宽放大模式（Loose augmentation）<br>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。<br>    　　<br>    var module1 = ( function (mod){<br>    　　　　//…<br>    　　　　return mod;<br>    　　})(window.module1 || {});<br>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。</p>
<p>##六、输入全局变量<br>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。<br>    　　<br>    var module1 = (function ($, YAHOO) {<br>    　　　　//…<br>    　　})(jQuery, YAHOO);<br>上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。这方面更多的讨论，参见Ben Cherry的著名文章《JavaScript Module Pattern: In-Depth》。<br>这个系列的第二部分，将讨论如何在浏览器环境组织不同的模块、管理模块之间的依赖性。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/04/Gulp/" itemprop="url">
                Gulp开发教程（转载）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-04T23:21:03+08:00" content="2015-09-04">
            2015-09-04
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端工具/" itemprop="url" rel="index">
                  <span itemprop="name">前端工具</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/04/Gulp/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/04/Gulp/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>转载地址 <a href="http://www.w3ctech.com/topic/134" target="_blank" rel="external">http://www.w3ctech.com/topic/134</a></p>
<p>对网站资源进行优化，并使用不同浏览器测试并不是网站设计过程中最有意思的部分，但是这个过程中的很多重复的任务能够使用正确的工具自动完成，从而使效率大大提高，这是让很多开发者觉得有趣的地方。</p>
<p>Gulp是一个构建系统，它能通过自动执行常见任务，比如编译预处理CSS，压缩JavaScript和刷新浏览器，来改进网站开发的过程。通过本文，我们将知道如何使用Gulp来改变开发流程，从而使开发更加快速高效。</p>
<p>##What Is Gulp?</p>
<p>Gulp是一个构建系统，开发者可以使用它在网站开发过程中自动执行常见任务。Gulp是基于Node.js构建的，因此Gulp源文件和你用来定义任务的Gulp文件都被写进了JavaScript（或者CoffeeScript）里。前端开发工程师还可以用自己熟悉的语言来编写任务去lint JavaScript和CSS、解析模板以及在文件变动时编译LESS文件（当然这些只是一小部分例子）。</p>
<p>Gulp本身虽然不能完成很多任务，但它有大量插件可用，开发者可以访问插件页面或者在npm搜索gulpplugin就能看到。例如，有些插件可以用来执行JSHint、编译CoffeeScript，执行Mocha测试，甚至更新版本号。</p>
<p>对比其他构建工具，比如Grunt，以及最近流行的Broccoli，我相信Gulp会更胜一筹（请看后面的”Why Gulp?”部分），同时我汇总了一个使用Javascript编写的构建工具清单，可供大家参考。</p>
<p>Gulp是一个可以在GitHub上找到的开源项目。</p>
<p>##Installing Gulp</p>
<p>安装Gulp的过程十分简单。首先，需要在全局安装Gulp包：</p>
<pre><code>npm install -g gulp
</code></pre><p>然后，在项目里面安装Gulp：</p>
<pre><code>npm install --save-dev gulp
</code></pre><p>##Using Gulp</p>
<p>现在我们创建一个Gulp任务来压缩JavaScript文件。首先创建一个名为gulpfile.js的文件，这是定义Gulp任务的地方，它可以通过gulp命令来运行，接着把下面的代码放到gulpfile.js文件里面。</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
   uglify = require(&apos;gulp-uglify&apos;);

gulp.task(&apos;minify&apos;, function () {
   gulp.src(&apos;js/app.js&apos;)
      .pipe(uglify())
      .pipe(gulp.dest(&apos;build&apos;))
});
</code></pre><p>然后在npm里面运行npm install -–save-dev gulp-uglify来安装gulp-uglify，最后通过运行gulp minify来执行任务。假设js目录下有个app.js文件，那么一个新的app.js将被创建在编译目录下，它包含了js/app.js的压缩内容。想一想，到底发生了什么？</p>
<p>我们只在gulpfile.js里做了一点事情。首先，我们加载gulp和gulp-uglify模块：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
    uglify = require(&apos;gulp-uglify&apos;);
</code></pre><p>然后，我们定义了一个叫minify的任务，它执行时会调用函数，这个函数会作为第二个参数：</p>
<pre><code>gulp.task(&apos;minify&apos;, function () {

});
</code></pre><p>最后，也是难点所在，我们需要定义任务应该做什么：</p>
<pre><code>gulp.src(&apos;js/app.js&apos;)
   .pipe(uglify())
   .pipe(gulp.dest(&apos;build&apos;))
</code></pre><p>如果你对数据流非常熟悉（其实大多数前端开发人员并不熟悉），上面所提供的代码对你来说就没有太大意义了。</p>
<p>##STREAMS</p>
<p>数据流能够通过一系列的小函数来传递数据，这些函数会对数据进行修改，然后把修改后的数据传递给下一个函数。</p>
<p>在上面的例子中，gulp.src()函数用字符串匹配一个文件或者文件的编号（被称为“glob”）,然后创建一个对象流来代表这些文件，接着传递给uglify()函数，它接受文件对象之后返回有新压缩源文件的文件对象，最后那些输出的文件被输入gulp.dest()函数，并保存下来。</p>
<p>整个数据流动过程如下图所示： </p>
<p>当只有一个任务的时候，函数并不会起太大的作用。然而，仔细思考下面的代码：</p>
<pre><code>gulp.task(&apos;js&apos;, function () {
   return gulp.src(&apos;js/*.js&apos;)
      .pipe(jshint())
      .pipe(jshint.reporter(&apos;default&apos;))
      .pipe(uglify())
      .pipe(concat(&apos;app.js&apos;))
      .pipe(gulp.dest(&apos;build&apos;));
});
</code></pre><p>在运行这段程序之前，你需要先安装gulp,gulp-jshint,gulp-uglify和gulp-concat。</p>
<p>这个任务会让所有的文件匹配js/*.js（比如js目录下的所有JavaScript文件），并且执行JSHint，然后打印输出结果，取消文件缩进，最后把他们合并起来，保存为build/app.js，整个过程如下图所示： </p>
<p>如果你对Grunt 足够熟悉，就会注意到，Gulp和Grunt的工作方式很不一样。Grunt不使用数据流，而是使用文件，对文件执行单个任务然后保存到新的文件中，每个任务都会重复执行所有进程，文件系统频繁的处理任务会导致Grunt的运行速度比Gulp慢。</p>
<p>如果想要获取更加全面的数据流知识，请查看“Stream Handbook”.</p>
<p>##GULP.SRC()</p>
<p>gulp.src()方法输入一个glob(比如匹配一个或多个文件的字符串)或者glob数组，然后返回一个可以传递给插件的数据流。</p>
<p>Gulp使用node-glob来从你指定的glob里面获取文件，这里列举下面的例子来阐述，方便大家理解：</p>
<pre><code>js/app.js 精确匹配文件
js/*.js 仅匹配js目录下的所有后缀为.js的文件
js/*/.js 匹配js目录及其子目录下所有后缀为.js的文件
!js/app.js 从匹配结果中排除js/app.js，这种方法在你想要匹配除了特殊文件之外的所有文件时非常管用
*.+(js|css) 匹配根目录下所有后缀为.js或者.css的文件
此外，Gulp也有很多其他的特征，但并不常用。如果你想了解更多的特征，请查看Minimatch文档。

js目录下包含了压缩和未压缩的JavaScript文件，现在我们想要创建一个任务来压缩还没有被压缩的文件，我们需要先匹配目录下所有的JavaScript文件，然后排除后缀为.min.js的文件:

gulp.src([&apos;js/**/*.js&apos;, &apos;!js/**/*.min.js&apos;])
</code></pre><p>##DEFINING TASKS</p>
<p>gulp.task()函数通常会被用来定义任务。当你定义一个简单的任务时，需要传入任务名字和执行函数两个属性。</p>
<pre><code>gulp.task(&apos;greet&apos;, function () {
   console.log(&apos;Hello world!&apos;);
});
</code></pre><p>执行gulp greet的结果就是在控制台上打印出“Hello world”.</p>
<p>一个任务有时也可以是一系列任务。假设要定义一个任务build来执行css、js、imgs这三个任务，我们可以通过指定一个任务数组而不是函数来完成。</p>
<pre><code>gulp.task(&apos;build&apos;, [&apos;css&apos;, &apos;js&apos;, &apos;imgs&apos;]);
</code></pre><p>这些任务不是同时进行的，所以你不能认为在js任务开始的时候css任务已经结束了，也可能还没有结束。为了确保一个任务在另一个任务执行前已经结束，可以将函数和任务数组结合起来指定其依赖关系。例如，定义一个css任务，在执行前需要检查greet任务是否已经执行完毕，这样做就是可行的:</p>
<pre><code>gulp.task(&apos;css&apos;, [&apos;greet&apos;], function () {
   // Deal with CSS here
});
</code></pre><p>现在，当执行css任务时，Gulp会先执行greet任务，然后在它结束后再调用你定义的函数。</p>
<p>##DEFAULT TASKS</p>
<p>你可以定义一个在gulp开始运行时候默认执行的任务，并将这个任务命名为“default”：</p>
<pre><code>gulp.task(&apos;default&apos;, function () {
   // Your default task
});
</code></pre><p>##PLUGINS</p>
<p>Gulp上有超过600种插件供你选择，你可以在插件页面或者npm上搜索gulpplugin来浏览插件列表。有些拥有“gulpfriendly”标签的插件，他们不能算插件，但是能在Gulp上正常运行。 需要注意的是，当直接在npm里搜索时，你无法知道某一插件是否在黑名单上（你需要滚动到插件页面底部才能看到）。</p>
<p>大多数插件的使用都很方便，它们都配有详细的文档，而且调用方法也相同（通过传递文件对象流给它），它们通常会对这些文件进行修改（但是有一些插件例外，比如validators），最后返回新的文件给下一个插件。</p>
<p>让我们用前面的js任务来详细说明一下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
    jshint = require(&apos;gulp-jshint&apos;),
    uglify = require(&apos;gulp-uglify&apos;),
    concat = require(&apos;gulp-concat&apos;);

gulp.task(&apos;js&apos;, function () {
   return gulp.src(&apos;js/*.js&apos;)
      .pipe(jshint())
      .pipe(jshint.reporter(&apos;default&apos;))
      .pipe(uglify())
      .pipe(concat(&apos;app.js&apos;))
      .pipe(gulp.dest(&apos;build&apos;));
});
</code></pre><p>这里使用了三个插件，gulp-jshint,gulp-uglify和gulp-concat。开发者可以参考插件的README文档，插件有很多配置选项，而且给定的初始值通常能满足需求。细心的读者可能会发现，程序中JSHint插件执行了2次，这是因为第一次执行JSHint只是给文件对象附加了jshint属性，并没有输出。你可以自己读取jshint的属性或者传递给默认的JSHint的接收函数或者其他的接收函数,比如jshint-stylish.</p>
<p>其他两个插件的作用很清楚：uglify()函数压缩代码，concat(‘app.js’)函数将所有文件合并到一个叫app.js的文件中。</p>
<p>##GULP-LOAD-PLUGINS</p>
<p>我发现gulp-load-plugin模块十分有用，它能够自动地从package.json中加载任意Gulp插件然后把它们附加到一个对象上。它的基本用法如下所示：</p>
<pre><code>var gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;),
    plugins = gulpLoadPlugins();
</code></pre><p>你可以把所有代码写到一行，但是我并不推荐这样做。</p>
<p>在执行那些代码之后，插件对象就已经包含了插件，并使用“驼峰式”的方式进行命名（例如，gulp-ruby-sass将被加载成plugins.rubySass），这样就可以很方便地使用了。例如，前面的js任务简化为如下：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
    gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;),
    plugins = gulpLoadPlugins();

gulp.task(&apos;js&apos;, function () {
   return gulp.src(&apos;js/*.js&apos;)
      .pipe(plugins.jshint())
      .pipe(plugins.jshint.reporter(&apos;default&apos;))
      .pipe(plugins.uglify())
      .pipe(plugins.concat(&apos;app.js&apos;))
      .pipe(gulp.dest(&apos;build&apos;));
});
</code></pre><p>假设package.json文件如下面所示：</p>
<pre><code>{
   &quot;devDependencies&quot;: {
      &quot;gulp-concat&quot;: &quot;~2.2.0&quot;,
      &quot;gulp-uglify&quot;: &quot;~0.2.1&quot;,
      &quot;gulp-jshint&quot;: &quot;~1.5.1&quot;,
      &quot;gulp&quot;: &quot;~3.5.6&quot;
   }
}
</code></pre><p>这个例子虽然已经够短了，但是使用更长更复杂的Gulp文件会把它们简化成一两行代码。</p>
<p>三月初发布的Gulp-load-plugins0.4.0版本添加了延迟加载功能，提高了插件的性能，因为插件在使用的时候才会被加载进来，你不用担心package.json里未被使用的插件影响性能（但是你需要把他们清理掉）。换句话说，如果你在执行任务时只需要两个插件，那么其他不相关的插件就不会被加载。</p>
<p>##WATCHING FILES</p>
<p>Gulp可以监听文件的修改动态，然后在文件被改动的时候执行一个或多个任务。这个特性十分有用（对我来说，这可能是Gulp中最有用的一个功能）。你可以保存LESS文件，接着Gulp会自动把它转换为CSS文件并更新浏览器。</p>
<p>使用gulp.watch()方法可以监听文件，它接受一个glob或者glob数组（和gulp.src()一样）以及一个任务数组来执行回调。</p>
<p>让我们看看下面，build任务可以将模板转换成html格式，然后我们希望定义一个watch任务来监听模板文件的变化，并将这些模板转换成html格式。watch函数的使用方法如下所示：</p>
<pre><code>gulp.task(&apos;watch&apos;, function () {
   gulp.watch(&apos;templates/*.tmpl.html&apos;, [&apos;build&apos;]);
});
</code></pre><p>现在，当改变一个模板文件时，build任务会被执行并生成HTML文件，也可以给watch函数一个回调函数，而不是一个任务数组。在这个示例中，回调函数有一个包含触发回调函数信息的event对象：</p>
<pre><code>gulp.watch(&apos;templates/*.tmpl.html&apos;, function (event) {
   console.log(&apos;Event type: &apos; + event.type); // added, changed, or deleted
   console.log(&apos;Event path: &apos; + event.path); // The path of the modified file
});
</code></pre><p>Gulp.watch()的另一个非常好的特性是返回我们熟知的watcher。利用watcher来监听额外的事件或者向watch中添加文件。例如，在执行一系列任务和调用一个函数时，你就可以在返回的watcher中添加监听change事件:</p>
<pre><code>var watcher = gulp.watch(&apos;templates/*.tmpl.html&apos;, [&apos;build&apos;]);
watcher.on(&apos;change&apos;, function (event) {
   console.log(&apos;Event type: &apos; + event.type); // added, changed, or deleted
   console.log(&apos;Event path: &apos; + event.path); // The path of the modified file
});
</code></pre><p>除了change事件，还可以监听很多其他的事件:</p>
<pre><code>end 在watcher结束时触发（这意味着，在文件改变的时候，任务或者回调不会执行）
error 在出现error时触发
ready 在文件被找到并正被监听时触发
nomatch 在glob没有匹配到任何文件时触发
Watcher对象也包含了一些可以调用的方法：

watcher.end() 停止watcher（以便停止执行后面的任务或者回调函数）
watcher.files() 返回watcher监听的文件列表
watcher.add(glob) 将与指定glob相匹配的文件添加到watcher（也接受可选的回调当第二个参数）
watcher.remove(filepath) 从watcher中移除个别文件
Reloading Changes In The Browser
</code></pre><p>当一个文件被修改或者Gulp任务被执行时可以用Gulp来加载或者更新网页。LiveReload和BrowserSync插件就可以用来实现在游览器中加载更新的内容。</p>
<p>##LIVERELOAD</p>
<p>LiveReload结合了浏览器扩展（包括Chrome extension），在发现文件被修改时会实时更新网页。它可以和gulp-watch插件或者前面描述的gulp-watch()函数一起使用。下面有一个gulp-livereload仓库中的README文件提到的例子:</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
    less = require(&apos;gulp-less&apos;),
    livereload = require(&apos;gulp-livereload&apos;),
    watch = require(&apos;gulp-watch&apos;);

gulp.task(&apos;less&apos;, function() {
   gulp.src(&apos;less/*.less&apos;)
      .pipe(watch())
      .pipe(less())
      .pipe(gulp.dest(&apos;css&apos;))
      .pipe(livereload());
});
</code></pre><p>这会监听到所有与less/*.less相匹配的文件的变化。一旦监测到变化，就会生成css并保存，然后重新加载网页.</p>
<p>##BROWSERSYNC</p>
<p>BroserSync在浏览器中展示变化的功能与LiveReload非常相似，但是它有更多的功能。</p>
<p>当你改变代码的时候，BrowserSync会重新加载页面，或者如果是css文件，会直接添加进css中，页面并不需要再次刷新。这项功能在网站是禁止刷新的时候是很有用的。假设你正在开发单页应用的第4页，刷新页面就会导致你回到开始页。使用LiveReload的话，你就需要在每次改变代码之后还需要点击四次，而当你修改CSS时，插入一些变化时，BrowserSync会直接将需要修改的地方添加进CSS，就不用再点击回退。</p>
<p>BrowserSync提供了一种在多个浏览器里测试网页的很好方式（查看大图）。</p>
<p>BrowserSync也可以在不同浏览器之间同步点击翻页、表单操作、滚动位置。你可以在电脑和iPhone上打开不同的浏览器然后进行操作。所有设备上的链接将会随之变化，当你向下滚动页面时，所有设备上页面都会向下滚动（通常还很流畅！）。当你在表单中输入文本时，每个窗口都会有输入。当你不想要这种行为时，也可以把这个功能关闭。</p>
<p>BrowserSync不需要使用浏览器插件，因为它本身就可以给你提供文件。（查看大图）</p>
<p>BrowserSync不需要使用浏览器插件，因为它本身就可以为你提供文件服务（如果文件是动态的，则为他们提供代理服务）和用来开启浏览器和服务器之间的socket的脚本服务。到目前为止这个功能的使用都十分顺畅。</p>
<p>实际上BrowserSync对于Gulp并不算一种插件，因为BrowserSync并不像一个插件一样操作文件。然而，npm上的BrowserSync模块能在Gulp上被直接调用。</p>
<p>首先，需要通过npm安装一下：</p>
<pre><code>npm install --save-dev browser-sync
</code></pre><p>然后gulpfile.js会启动BrowserSync并监听文件：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
    browserSync = require(&apos;browser-sync&apos;);

gulp.task(&apos;browser-sync&apos;, function () {
   var files = [
      &apos;app/**/*.html&apos;,
      &apos;app/assets/css/**/*.css&apos;,
      &apos;app/assets/imgs/**/*.png&apos;,
      &apos;app/assets/js/**/*.js&apos;
   ];

   browserSync.init(files, {
      server: {
         baseDir: &apos;./app&apos;
      }
   });
});
</code></pre><p>执行gulp browser-sync后会监听匹配文件的变化，同时为app目录提供文件服务。</p>
<p>此外BrowserSync的开发者还写了很多关于BrowserSync+Gulp仓库的其他用途。</p>
<p>##Why Gulp?</p>
<p>前面提到过，Gulp是为数不多的使用JavaScript开发的构建工具之一，也有其他不是用JavaScript开发的构建工具，比如Rake，那么我们为什么要选择Gulp呢?</p>
<p>目前最流行的两种使用JavaScript开发的构建工具是Grunt和Gulp。Grunt在2013年非常流行，因为它彻底改变了许多人开发网站的方式，它有上千种插件可供用户使用，从linting、压缩、合并代码到使用Bower安装程序包,启动Express服务都能办到。这些和Gulp的很不一样，Gulp只有执行单个小任务来处理文件的插件，因为任务都是JavaScript（和Grunt使用的大型对象不同），根本不需要插件，你只需用传统方法启动一个Express服务就可以了。</p>
<p>Grunt任务拥有大量的配置，会引用大量你实际上并不需要的对象属性，但是Gulp里同样的任务也许只有几行。让我们看个简单的Gruntfile.js，它规定一个将LESS转换为CSS的任务，然后执行Autoprefixer:</p>
<pre><code>grunt.initConfig({
   less: {
      development: {
         files: {
            &quot;build/tmp/app.css&quot;: &quot;assets/app.less&quot;
         }
      }
   },

   autoprefixer: {
      options: {
         browsers: [&apos;last 2 version&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;]
      },
      multiple_files: {
         expand: true,
         flatten: true,
         src: &apos;build/tmp/app.css&apos;,
         dest: &apos;build/&apos;
      }
   }
});

grunt.loadNpmTasks(&apos;grunt-contrib-less&apos;);
grunt.loadNpmTasks(&apos;grunt-autoprefixer&apos;);

grunt.registerTask(&apos;css&apos;, [&apos;less&apos;, &apos;autoprefixer&apos;]);
</code></pre><p>与Gulpfile.js文件进行对比，它们执行的任务相同：</p>
<pre><code>var gulp = require(&apos;gulp&apos;),
   less = require(&apos;gulp-less&apos;),
   autoprefix = require(&apos;gulp-autoprefixer&apos;);

gulp.task(&apos;css&apos;, function () {
   gulp.src(&apos;assets/app.less&apos;)
      .pipe(less())
      .pipe(autoprefix(&apos;last 2 version&apos;, &apos;ie 8&apos;, &apos;ie 9&apos;))
      .pipe(gulp.dest(&apos;build&apos;));
});
</code></pre><p>因为Grunt比Gulp更加频繁地操作文件系统，所以使用数据流的Gulp总是比Grunt快。对于一个小的LESS文件，gulpfile.js通常需要6ms，而gruntfile.js则需要大概50ms——慢8倍多。这只是个简单的例子，对于长的文件，这个数字会增加得更显著。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/04/cnpm/" itemprop="url">
                cnpm--淘宝的nodejs镜像
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-04T23:14:31+08:00" content="2015-09-04">
            2015-09-04
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/04/cnpm/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/04/cnpm/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>我已经对中国局域网无力吐槽了，不过本来外网速度也慢，话不多说</p>
<p>淘宝镜像详情请访问 <code>http://npm.taobao.org/</code></p>
<p>##mac下配置<br>    vim ~/.bash_profile</p>
<pre><code>alias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \
--cache=$HOME/.npm/.cache/cnpm \
--disturl=https://npm.taobao.org/dist \
--userconfig=$HOME/.cnpmrc&quot;
</code></pre><p>之后就可以愉快的cnpm install –save-dev [module]</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/04/less/" itemprop="url">
                LESS CSS 框架简介(转载)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on
          <time itemprop="dateCreated" datetime="2015-09-04T20:41:37+08:00" content="2015-09-04">
            2015-09-04
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; In
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/css/" itemprop="url" rel="index">
                  <span itemprop="name">css</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/04/less/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/04/less/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>这篇文章转载自<code>http://www.ibm.com/developerworks/cn/web/1207_zhaoch_lesscss/</code></p>
<p>##简介<br>CSS（层叠样式表）是一门历史悠久的标记性语言，同 HTML 一道，被广泛应用于万维网（World Wide Web）中。HTML 主要负责文档结构的定义，CSS 负责文档表现形式或样式的定义。<br>作为一门标记性语言，CSS 的语法相对简单，对使用者的要求较低，但同时也带来一些问题：CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码，造成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。</p>
<p>##LESS 原理及使用方式<br>本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。下面是一个简单的例子：<br>清单 1. LESS 文件</p>
<pre><code>@color: #4D926F; 

#header { 
 color: @color; 
} 
h2 { 
 color: @color; 
}
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 2. CSS 文件</p>
<pre><code>#header { 
 color: #4D926F; 
} 
h2 { 
 color: #4D926F; 
}
</code></pre><p>从上面的例子可以看出，学习 LESS 非常容易，只要你了解 CSS 基础就可以很容易上手。<br>LESS 可以直接在客户端使用，也可以在服务器端使用。在实际项目开发中，我们更推荐使用第三种方式，将 LESS 文件编译生成静态 CSS 文件，并在 HTML 文档中应用。<br>客户端<br>我们可以直接在客户端使用 .less（LESS 源文件），只需要从 <a href="http://lesscss.org下载" target="_blank" rel="external">http://lesscss.org下载</a> less.js 文件，然后在我们需要引入 LESS 源文件的 HTML 中加入如下代码：</p>
<pre><code>&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot;&gt;
</code></pre><p>LESS 源文件的引入方式与标准 CSS 文件引入方式一样：</p>
<pre><code>&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot;&gt;
</code></pre><p>需要注意的是：在引入 .less 文件时，rel 属性要设置为“stylesheet/less”。还有更重要的一点需要注意的是：LESS 源文件一定要在 less.js 引入之前引入，这样才能保证 LESS 源文件正确编译解析。<br>服务器端<br>LESS 在服务器端的使用主要是借助于 LESS 的编译器，将 LESS 源文件编译生成最终的 CSS 文件，目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译。<br>在项目开发初期，我们无论采用客户端还是服务器端的用法，我们都需要想办法将我们要用到的 CSS 或 LESS 文件引入到我们的 HTML 页面或是桥接文件中，LESS 提供了一个我们很熟悉的功能— Importing。我们可以通过这个关键字引入我们需要的 .less 或 .css 文件。 如：</p>
<pre><code>@import “variables.less”;
</code></pre><p>.less 文件也可以省略后缀名，像这样：</p>
<pre><code>@import “variables”;
</code></pre><p>引入 CSS 同 LESS 文件一样，只是 .css 后缀名不能省略。<br>使用编译生成的静态 CSS 文件<br>我们可以通过 LESS 的编译器，将 LESS 文件编译成为 CSS 文件，在 HTML 文章中引入使用。这里要强调的一点，LESS 是完全兼容 CSS 语法的，也就是说，我们可以将标准的 CSS 文件直接改成 .less 格式，LESS 编译器可以完全识别。</p>
<p>##语法</p>
<p>###变量<br>LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单。<br>我们可以从下面的代码了解变量的使用及作用：<br>清单 3 LESS 文件</p>
<pre><code>@border-color : #b5bcc7; 

.mythemes tableBorder{ 
  border : 1px solid @border-color; 
}
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 4. CSS 文件</p>
<pre><code>.mythemes tableBorder { 
 border: 1px solid #b5bcc7; 
}
</code></pre><p>从上面的代码中我们可以看出，变量是 VALUE（值）级别的复用，可以将相同的值定义成变量统一管理起来。<br>该特性适用于定义主题，我们可以将背景颜色、字体颜色、边框属性等常规样式进行统一定义，这样不同的主题只需要定义不同的变量文件就可以了。当然该特性也同样适用于 CSS RESET（重置样式表），在 Web 开发中，我们往往需要屏蔽浏览器默认的样式行为而需要重新定义样式表来覆盖浏览器的默认行为，这里可以使用 LESS 的变量特性，这样就可以在不同的项目间重用样式表，我们仅需要在不同的项目样式表中，根据需求重新给变量赋值即可。<br>LESS 中的变量和其他编程语言一样，可以实现值的复用，同样它也有生命周期，也就是 Scope（变量范围，开发人员惯称之为作用域），简单的讲就是局部变量还是全局变量的概念，查找变量的顺序是先在局部定义中找，如果找不到，则查找上级定义，直至全局。下面我们通过一个简单的例子来解释 Scope。<br>清单 5. LESS 文件</p>
<pre><code>@width : 20px; 
#homeDiv { 
  @width : 30px; 
  #centerDiv{ 
      width : @width;// 此处应该取最近定义的变量 width 的值 30px 
             } 
} 
#leftDiv { 
    width : @width; // 此处应该取最上面定义的变量 width 的值 20px 

}
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 6. CSS 文件</p>
<pre><code>#homeDiv #centerDiv { 
 width: 30px; 
} 
#leftDiv { 
 width: 20px; 
}
</code></pre><p>###Mixins（混入）<br>Mixins（混入）功能对用开发者来说并不陌生，很多动态语言都支持 Mixins（混入）特性，它是多重继承的一种实现，在 LESS 中，混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样。<br>我们先简单看一下 Mixins 在 LESS 中的使用：<br>清单 7. LESS 文件</p>
<pre><code>// 定义一个样式选择器
 .roundedCorners(@radius:5px) { 
 -moz-border-radius: @radius; 
 -webkit-border-radius: @radius; 
 border-radius: @radius; 
 } 
 // 在另外的样式选择器中使用
 #header { 
 .roundedCorners; 
 } 
 #footer { 
 .roundedCorners(10px); 
 }
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 8. CSS 文件</p>
<pre><code>#header { 
-moz-border-radius:5px; 
-webkit-border-radius:5px; 
border-radius:5px; 
} 
#footer { 
-moz-border-radius:10px; 
-webkit-border-radius:10px; 
border-radius:10px; 
}
</code></pre><p>从上面的代码我们可以看出：Mixins 其实是一种嵌套，它允许将一个类嵌入到另外一个类中使用，被嵌入的类也可以称作变量，简单的讲，Mixins 其实是规则级别的复用。<br>Mixins 还有一种形式叫做 Parametric Mixins（混入参数），LESS 也支持这一特性：<br>清单 9. LESS 文件<br>// 定义一个样式选择器</p>
<pre><code>.borderRadius(@radius){ 
-moz-border-radius: @radius; 
-webkit-border-radius: @radius; 
border-radius: @radius; 
} 
// 使用已定义的样式选择器
#header { 
.borderRadius(10px); // 把 10px 作为参数传递给样式选择器
} 
.btn { 
.borderRadius(3px);// // 把 3px 作为参数传递给样式选择器

}
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 10. CSS 文件</p>
<pre><code>#header { 
-moz-border-radius: 10px; 
-webkit-border-radius: 10px; 
border-radius: 10px; 
} 
.btn { 
-moz-border-radius: 3px; 
-webkit-border-radius: 3px; 
border-radius: 3px; 
}
</code></pre><p>我们还可以给 Mixins 的参数定义一人默认值，如<br>清单 11. LESS 文件</p>
<pre><code>.borderRadius(@radius:5px){ 
 -moz-border-radius: @radius; 
 -webkit-border-radius: @radius; 
 border-radius: @radius; 
 } 
 .btn { 
 .borderRadius; 
 }
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 12. CSS 文件</p>
<pre><code>.btn { 
-moz-border-radius: 5px; 
-webkit-border-radius: 5px; 
border-radius: 5px; 
}
</code></pre><p>像 JavaScript 中 arguments一样，Mixins 也有这样一个变量：@arguments。@arguments 在 Mixins 中具是一个很特别的参数，当 Mixins 引用这个参数时，该参数表示所有的变量，很多情况下，这个参数可以省去你很多代码。<br>清单 13. LESS 文件</p>
<pre><code>.boxShadow(@x:0,@y:0,@blur:1px,@color:#000){ 
-moz-box-shadow: @arguments; 
-webkit-box-shadow: @arguments; 
box-shadow: @arguments; 
} 
#header { 
.boxShadow(2px,2px,3px,#f36); 
}
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 14. CSS 文件</p>
<pre><code>#header { 
-moz-box-shadow: 2px 2px 3px #FF36; 
-webkit-box-shadow: 2px 2px 3px #FF36; 
box-shadow: 2px 2px 3px #FF36; 
}
</code></pre><p>Mixins 是 LESS 中很重要的特性之一，我们这里也写了很多例子，看到这些例子你是否会有这样的疑问：当我们拥有了大量选择器的时候，特别是团队协同开发时，如何保证选择器之间重名问题？如果你是 java 程序员或 C++ 程序员，我猜你肯定会想到命名空间 Namespaces，LESS 也采用了命名空间的方法来避免重名问题，于是乎 LESS 在 mixins 的基础上扩展了一下，看下面这样一段代码：<br>清单 15. LESS 文件</p>
<pre><code>#mynamespace { 
.home {...} 
.user {...} 
}
</code></pre><p>这样我们就定义了一个名为 mynamespace 的命名空间，如果我们要复用 user 这个选择器的时候，我们只需要在需要混入这个选择器的地方这样使用就可以了。#mynamespace &gt; .user。</p>
<p>###嵌套的规则<br>在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式。在 LESS 中我们可以这样写：<br>清单 16. HTML 片段</p>
<pre><code>&lt;div id=&quot;home&quot;&gt; 
&lt;div id=&quot;top&quot;&gt;top&lt;/div&gt; 
&lt;div id=&quot;center&quot;&gt; 
&lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; 
&lt;div id=&quot;right&quot;&gt;right&lt;/div&gt; 
&lt;/div&gt; 
&lt;/div&gt;
</code></pre><p>清单 17. LESS 文件</p>
<pre><code>#home{ 
  color : blue; 
  width : 600px; 
  height : 500px; 
  border:outset; 
  #top{ 
       border:outset; 
       width : 90%; 
  } 
  #center{ 
       border:outset; 
       height : 300px; 
       width : 90%; 
       #left{ 
         border:outset; 
         float : left; 
         width : 40%; 
       } 
       #right{ 
         border:outset; 
         float : left; 
         width : 40%; 
       } 
   } 
}
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 18. CSS 文件</p>
<pre><code>#home { 
 color: blue; 
 width: 600px; 
 height: 500px; 
 border: outset; 
} 
#home #top { 
 border: outset; 
 width: 90%; 
} 
#home #center { 
 border: outset; 
 height: 300px; 
 width: 90%; 
} 
#home #center #left { 
 border: outset; 
 float: left; 
 width: 40%; 
} 
#home #center #right { 
 border: outset; 
 float: left; 
 width: 40%; 
}
</code></pre><p>从上面的代码中我们可以看出，LESS 的嵌套规则的写法是 HTML 中的 DOM 结构相对应的，这样使我们的样式表书写更加简洁和更好的可读性。同时，嵌套规则使得对伪元素的操作更为方便。<br>清单 19. LESS 文件</p>
<pre><code>a { 
 color: red; 
 text-decoration: none; 
 &amp;:hover {// 有 &amp; 时解析的是同一个元素或此元素的伪类，没有 &amp; 解析是后代元素
  color: black; 
  text-decoration: underline; 
 } 
 }
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 20. CSS 文件</p>
<pre><code> a { 
 color: red; 
 text-decoration: none; 
 } 
 a:hover { 
 color: black; 
 text-decoration: underline; 
 }
运算及函数
</code></pre><p>在我们的 CSS 中充斥着大量的数值型的 value，比如 color、padding、margin 等，这些数值之间在某些情况下是有着一定关系的，那么我们怎样利用 LESS 来组织我们这些数值之间的关系呢？我们来看这段代码：<br>清单 21 . LESS 文件</p>
<pre><code>@init: #111111; 
@transition: @init*2; 
.switchColor { 
color: @transition; 
}
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 22. CSS 文件<br>     .switchColor {<br>      color: #222222;<br>     }<br>上面的例子中使用 LESS 的 operation 是 特性，其实简单的讲，就是对数值型的 value（数字、颜色、变量等）进行加减乘除四则运算。同时 LESS 还有一个专门针对 color 的操作提供一组函数。下面是 LESS 提供的针对颜色操作的函数列表：</p>
<pre><code>lighten(@color, 10%); // return a color which is 10% *lighter* than @color 
darken(@color, 10%); // return a color which is 10% *darker* than @color 
saturate(@color, 10%); // return a color 10% *more* saturated than @color 
desaturate(@color, 10%);// return a color 10% *less* saturated than @color 
fadein(@color, 10%); // return a color 10% *less* transparent than @color 
fadeout(@color, 10%); // return a color 10% *more* transparent than @color 
spin(@color, 10); // return a color with a 10 degree larger in hue than @color 
spin(@color, -10); // return a color with a 10 degree smaller hue than @color
</code></pre><p>PS: 上述代码引自 LESS CSS 官方网站，详情请见 <a href="http://lesscss.org/#-color-functions" target="_blank" rel="external">http://lesscss.org/#-color-functions</a><br>使用这些函数和 JavaScript 中使用函数一样。<br>清单 23 LESS 文件</p>
<pre><code>init: #f04615; 
 #body { 
  background-color: fadein(@init, 10%); 
 }
</code></pre><p>经过编译生成的 CSS 文件如下：<br>清单 24. CSS 文件</p>
<pre><code>#body { 
 background-color: #f04615; 
}
</code></pre><p>从上面的例子我们可以发现，这组函数像极了 JavaScript 中的函数，它可以被调用和传递参数。这些函数的主要作用是提供颜色变换的功能，先把颜色转换成 HSL 色，然后在此基础上进行操作，LESS 还提供了获取颜色值的方法，在这里就不举例说明了。<br>LESS 提供的运算及函数特性适用于实现页面组件特性，比如组件切换时的渐入渐出。</p>
<p>###Comments（注释）<br>适当的注释是保证代码可读性的必要手段，LESS 对注释也提供了支持，主要有两种方式：单行注释和多行注释，这与 JavaScript 中的注释方法一样，我们这里不做详细的说明，只强调一点：LESS 中单行注释 (// 单行注释 ) 是不能显示在编译后的 CSS 中，所以如果你的注释是针对样式说明的请使用多行注释。</p>
<p>##LESS VS SASS<br>同类框架还有 SASS : <a href="http://sass-lang.com/" target="_blank" rel="external">http://sass-lang.com/</a>, 与 LESS 相比，两者都属于 CSS 预处理器，功能上大同小异，都是使用类似程序式语言的方式书写 CSS, 都具有变量、混入、嵌套、继承等特性，最终目的都是方便 CSS 的书写及维护。<br>LESS 和 SASS 互相促进互相影响，相比之下 LESS 更接近 CSS 语法，更多两者之间的比较，请参考这篇帖子：<a href="https://gist.github.com/674726。" target="_blank" rel="external">https://gist.github.com/674726。</a></p>
<p>##结束语<br>本文提到的只是 LESS 的基本功能，更高级的功能如：字符串插值，服务器端使用配置，JavaScript 表达式，避免编译等可以参看 LESS 的官方网站。<br>LESS 以 CSS 语法为基础，又借用了很多我们熟知编程式语言的特性，这对于我们开发人员来讲学习成本几乎可以忽略，它在保留 CSS 语法的基础上扩展了更多实用的功能，LESS 为我们提供了一种新的编写样式表的方法，我们可以根据我们的项目特性选择使用 LESS 的部分特性，我们只需用很少的成本就可以换了很大的回报，一句话，Less is more，借助 LESS 可以更便捷的进行 Web 开发。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://7xltvd.com1.z0.glb.clouddn.com/default_avatar.jpg" alt="zhanfang" itemprop="image"/>
          <p class="site-author-name" itemprop="name">zhanfang</p>
        </div>
        <p class="site-description motion-element" itemprop="description">詹方的个人博客</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">145</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">categories</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">79</span>
              <span class="site-state-item-name">tags</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhanfang" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2840048377/profile?topnav=1&wvr=6" target="_blank">Weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.demozhan.com/default" target="_blank">我的作品</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhanfang</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>
<div class="theme-info">© zhanfang 2015 陕ICP备15014665号-1</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhanfang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>

  <script>
    (function(){
        var bp = document.createElement('script');
        bp.src = '//push.zhanzhang.baidu.com/push.js';
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
  </script>

</body>
</html>
